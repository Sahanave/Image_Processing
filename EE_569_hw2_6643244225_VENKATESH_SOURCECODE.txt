Problem 1:
1)a

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/

using namespace std;
int Height=500;//Change the input image sizes here.
int Width=500;
int Bytesperpixel=3;
FILE *file;
unsigned char Imagedata[500][500][3];
unsigned char outImagedata[500][500][3];

void linear()
{

    int i;
    int j;
   int counter;
   int no_of_points;
    int p;
float scale;//scale factor
float ratio_image;
int count_end;
int count_begin;
int middle=floor((1.0*Height)/2)-1;
//Upper triangel in the output index
for(i=0;i<=middle;i++)
        {
              counter=0;
            no_of_points=2*(i)+1;
    ratio_image=(1.0*no_of_points/Width);
        for(j=middle-i;j<=middle+i;j++)
        {
            //lINEAR INTERPOLATION
               p=(int)(1.0*counter/ratio_image);
                outImagedata[i][j][0]=int(Imagedata[i][p][0]);
                outImagedata[i][j][1]=int(Imagedata[i][p][1]);
                outImagedata[i][j][2]=int(Imagedata[i][p][2]);
                counter++;


}

        }
//Lower triangel in the output index
   for(i=middle+1;i<(Height-1);i++)
        {
            counter=0;
count_begin=i-middle;
count_end=(Width-1)-count_begin;
ratio_image=(1.0*no_of_points/Width);
no_of_points=count_end-count_begin+1;

        for(j=count_begin;j<=count_end;j++)
        {
               p=(int)(1.0*counter/ratio_image);
                outImagedata[i][j][0]=int(Imagedata[i][p][0]);
                outImagedata[i][j][1]=int(Imagedata[i][p][1]);
                outImagedata[i][j][2]=int(Imagedata[i][p][2]);

counter++;


}

        }

}






int main()
{
    int i;
    FILE *file;
    if (!(file=fopen("cup2.raw","rb")))//CHANGE THE INPUT IMAGE NAME HERE
        {
    cout << "Cannot open file: " <<endl;
    exit(1);
}
fread(Imagedata, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
cout<<" Reading the image"<<endl;
int j;
for(i=0;i<500;i++)
{
    for(j=0;j<500;j++)
 {
     outImagedata[i][j][0]=0;
      outImagedata[i][j][1]=0;
       outImagedata[i][j][2]=0;
 }
}
linear();

	if (!(file=fopen("cup_2linear.raw","wb"))) {//CHANGE THE OUTPUT IMAGE NAME HERE
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fwrite(outImagedata, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
	fclose(file);
	cout<<"Resizing the above image to the above image would be stored in your directory cup1_image.raw"<<endl;


return 0;
}
(b)Triangluar Warping 
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/

using namespace std;
int Height=500;
int Width=500;
int Bytesperpixel=3;
FILE *file;
int points[9][2];
int points_output[9][2];
float cartesian_input[9][2];
float cartesian_output[9][2];
unsigned char Imagedata[500][500][3];//Input image
unsigned char outImagedata[500][500][3];//Output image

void triangle()
{
    int i;
    int j;
    float x;//cartesian cooridinate for outut
    float y;//cartesian cooridinate for outut
    float p;
float q;
float u;//cartesian cooridinate for input
float v;//cartesian cooridinate for input
int p1;
int q1;
float a;
float b;
//EIght matrices according to the triangles
    float triangle_1[3][3]={{2,0,-249.5},{-1,1,249.5},{0,0,1}};

    float triangle_2[3][3]={{2,0,-249.5},{0.98,1,-246.5},{0,0,1}};

    float triangle_3[3][3]={{1,1,-250.98},{0,2,-250.5},{0,0,1}};

    float triangle_4[3][3]={{1,-1,250.5},{0,2,-250.5},{0,0,1}};

    float triangle_5[3][3]={{2,0,-249.5},{-1,1,249.5},{0,0,1}};

    float triangle_6[3][3]={{2,0,-249.5},{1,1,-249.5},{0,0,1}};

    float triangle_7[3][3]={{1,0.98,-247.49},{0,2,-250.5},{0,0,1}};

    float triangle_8[3][3]={{1,-1,-250.5},{0,2,-250.5},{0,0,1}};

//Quadrant 1
    for(i=0;i<250;i++)
        {
        for(j=0;j<250;j++)
        {
            x=(j)-(1.0/2);
            y=500-(i)+(1.0/2);

            if(y-x-250.0<=0)
            {

                if(y+x-500>0)
                {

                 u=(triangle_1[0][0]*x)+(triangle_1[0][1]*y)+triangle_1[0][2];
                 v=(triangle_1[1][0]*x)+(triangle_1[1][1]*y)+triangle_1[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);
                p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


            }
            else

            {

             u=(triangle_8[0][0]*x)+(triangle_8[0][1]*y)+triangle_8[0][2];
                 v=(triangle_8[1][0]*x)+(triangle_8[1][1]*y)+triangle_8[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);


  p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


        }
        }
        }
 }
//Quadrant 2
   for(i=0;i<250;i++)
        {
        for(j=250;j<500;j++)
        {
            x=(j)-(1.0/2);
            y=500-(i)+(1.0/2);

            if(y+(0.9960*x)-748.0<=0)
            {
                if(y-(0.9960*x)-1.998>0)
                {
                 u=(triangle_2[0][0]*x)+(triangle_2[0][1]*y)+triangle_2[0][2];
                 v=(triangle_2[1][0]*x)+(triangle_2[1][1]*y)+triangle_2[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);

              p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


            }
            else

            {

             u=(triangle_3[0][0]*x)+(triangle_3[0][1]*y)+triangle_3[0][2];
                 v=(triangle_3[1][0]*x)+(triangle_3[1][1]*y)+triangle_3[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);
               p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));
        }
        }
        }
        }
//Quadrant 3
for(i=250;i<500;i++)
        {
        for(j=0;j<250;j++)
        {
            x=(j)-(1.0/2);
            y=500-(i)-(1.0/2);

            if(y+(x)-251>=0)
            {
                if(y-x+0.0020>0)
                {
                 u=(triangle_7[0][0]*x)+(triangle_7[0][1]*y)+triangle_7[0][2];
                 v=(triangle_7[1][0]*x)+(triangle_7[1][1]*y)+triangle_7[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);

             p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


            }
            else

            {

             u=(triangle_6[0][0]*x)+(triangle_6[0][1]*y)+triangle_6[0][2];
                 v=(triangle_6[1][0]*x)+(triangle_6[1][1]*y)+triangle_6[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);



                  p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));

        }
        }
        }
        }
        //Quadrant 4

for(i=250;i<500;i++)
        {
        for(j=250;j<500;j++)
        {
            x=(j)-(1.0/2);
            y=500-(i)-(1.0/2);

            if(y-x+249>=0)
            {
                if(y+(x)-500>0)
                {
                 u=(triangle_4[0][0]*x)+(triangle_4[0][1]*y)+triangle_4[0][2];
                 v=(triangle_4[1][0]*x)+(triangle_4[1][1]*y)+triangle_4[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);


  p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));

            }
            else

            {

             u=(triangle_5[0][0]*x)+(triangle_5[0][1]*y)+triangle_5[0][2];
                 v=(triangle_5[1][0]*x)+(triangle_5[1][1]*y)+triangle_5[1][2];
                 p=(500-v+(1.0/2));
                 q=u+(1.0/2);


  p1=floor(p);
              q1=floor(q);
               b=p-p1;
               a=q-q1;


                outImagedata[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
                outImagedata[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
                outImagedata[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


        }
        }
        }
        }





}

void point_to_cartesian()
{
    int i;
    for(i=0;i<9;i++)
    {
       cartesian_input[i][0]=points[i][1]-(1.0/2);
       cartesian_input[i][1]=(500)-points[i][0]+(1.0/2);
    }
}

int main()
{
    int i;
    FILE *file;
    if (!(file=fopen("cup1.raw","rb")))//change the input file name here
        {
    cout << "Cannot open file: " <<endl;
    exit(1);
}
fread(Imagedata, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
cout<<" Reading the image"<<endl;
points[1][0]=1;
points[1][1]=1;
points[2][0]=1;
points[2][1]=250;
points[3][0]=1;
points[3][1]=500;
points[4][0]=250;
points[4][1]=500;
points[5][0]=500;
points[5][1]=500;
points[6][0]=500;
points[6][1]=250;
points[7][0]=500;
points[7][1]=1;
points[8][0]=250;
points[8][1]=1;
points[0][0]=250;
points[0][1]=250;

point_to_cartesian();
cartesian_output[0][0]=cartesian_input[0][0];
cartesian_output[0][1]=cartesian_input[0][1];
cartesian_output[2][0]=cartesian_input[2][0];
cartesian_output[2][1]=cartesian_input[2][1];

cartesian_output[4][0]=cartesian_input[4][0];
cartesian_output[4][1]=cartesian_input[4][1];

cartesian_output[6][0]=cartesian_input[6][0];
cartesian_output[6][1]=cartesian_input[6][1];

cartesian_output[8][0]=cartesian_input[8][0];
cartesian_output[8][1]=cartesian_input[8][1];

cartesian_output[1][0]=(cartesian_input[2][0]+cartesian_input[8][0])/2;

cartesian_output[1][1]=(cartesian_input[2][1]+cartesian_input[8][1])/2;

cartesian_output[3][0]=(cartesian_input[2][0]+cartesian_input[4][0])/2;
cartesian_output[3][1]=(cartesian_input[2][1]+cartesian_input[4][1])/2;

cartesian_output[5][0]=(cartesian_input[4][0]+cartesian_input[6][0])/2;
cartesian_output[5][1]=(cartesian_input[4][1]+cartesian_input[6][1])/2;

cartesian_output[7][0]=(cartesian_input[8][0]+cartesian_input[6][0])/2;
cartesian_output[7][1]=(cartesian_input[8][1]+cartesian_input[6][1])/2;


    for(i=0;i<9;i++)
    {
       cout<<i<<endl;
       cout<<"x"<<endl;
       cout<<cartesian_input[i][0]<<endl;
       cout<<"y"<<endl;
       cout<<cartesian_input[i][1]<<endl;
       cout<<"output"<<endl;
          cout<<cartesian_output[i][0]<<endl;
       cout<<"y"<<endl;
       cout<<cartesian_output[i][1]<<endl;

    }

int j;
for(i=0;i<500;i++)
{
    for(j=0;j<500;j++)
 {
     outImagedata[i][j][0]=0;
      outImagedata[i][j][1]=0;
       outImagedata[i][j][2]=0;
 }
}
triangle();

	if (!(file=fopen("cup_1_output.raw","wb"))) {
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fwrite(outImagedata, sizeof(unsigned char),500*500*3, file);
	fclose(file);
	cout<<"Resizing the above image to (requested dimensions) the above image would be stored in your directory as output_image.raw"<<endl;


return 0;
}
1.b)Hillary and trump

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/

using namespace std;

FILE *file;
unsigned char Imagedata[500][500][3];
unsigned char hillary[512][512][3];
unsigned char trump[512][512][3];
unsigned char outImagedata[512][512][3];//Output of the hole filling algorithm
unsigned char outImagedata_median[512][512][3];//output of the hole filling algorithm processed by median filter
unsigned char outImagedata_trump[512][512][3];//Output of the hole filling algorithm
unsigned char outImagedata_median_trump[512][512][3];//output of the hole filling algorithm processed by median filter


int corner[4][2]={{0,0},{0,0},{0,0},{0,0}};

int corner_hils[4][2]={{0,0},{0,0},{0,0},{0,0}};
int corner_trump[4][2]={{0,0},{0,0},{0,0},{0,0}};
//to find the corner points of the missing piece in the piece.raw image
void hillary_piece()
{
int i;
int j;
int Width=500;
int counter=0;
int mini_j=500;
int maxi=0;
int max_i=0;

for(i=1;i<=260-1;i++)
{
for(j=1;j<Width-1;j++)
{

if((Imagedata[i][j][0]!=255)&&(Imagedata[i][j][1]!=255)&&(Imagedata[i][j][2]!=255))
{

if(counter==0)
{
if((Imagedata[i-1][j][0]==255)&&(Imagedata[i-1][j][1]==255)&&(Imagedata[i-1][j][2]==255))
{
if((Imagedata[i][j-1][0]==255)&&(Imagedata[i][j-1][1]==255)&&(Imagedata[i][j-1][2]==255))
{
if((Imagedata[i+1][j][0]!=255)&&(Imagedata[i+1][j][1]!=255)&&(Imagedata[i+1][j][2]!=255))
{

corner[0][0]=i;
corner[0][1]=j;
counter++;
}


}
}
}


if((Imagedata[i-1][j][0]!=255)&&(Imagedata[i-1][j][1]!=255)&&(Imagedata[i-1][j][2]!=255)&&(Imagedata[i][j+1][0]==255)&&(Imagedata[i][j+1][1]==255)&&(Imagedata[i][j+1][2]==255)&&(Imagedata[i+1][j][0]==255)&&(Imagedata[i+1][j][1]==255)&&(Imagedata[i+1][j][2]==255))
{
if(i>max_i)

{
corner[2][0]=i;
corner[2][1]=j;
max_i=i;

}
}


if((Imagedata[i-1][j][0]==255)&&(Imagedata[i-1][j][1]==255)&&(Imagedata[i-1][j][2]==255)&&(Imagedata[i][j+1][0]==255)&&(Imagedata[i][j+1][1]==255)&&(Imagedata[i][j+1][2]==255))
{
if((Imagedata[i+1][j][0]==255)&&(Imagedata[i+1][j][1]==255)&&(Imagedata[i+1][j][2]==255))
{
if((Imagedata[i][j-1][0]!=255)&&(Imagedata[i][j-1][1]!=255)&&(Imagedata[i][j-1][2]!=255))
{
if(j>maxi)

{
  corner[3][0]=i;
corner[3][1]=j;
maxi=j;


}
}
}
}
if((Imagedata[i-1][j][0]!=255)&&(Imagedata[i-1][j][1]!=255)&&(Imagedata[i-1][j][2]!=255)&&(Imagedata[i][j+1][0]!=255)&&(Imagedata[i][j+1][1]!=255)&&(Imagedata[i][j+1][2]!=255))
{
   if((Imagedata[i+1][j][0]==255)&&(Imagedata[i+1][j][1]==255)&&(Imagedata[i+1][j][2]==255)&&(Imagedata[i][j-1][0]==255)&&(Imagedata[i][j-1][1]==255)&&(Imagedata[i][j-1][2]==255))
{
if(j<mini_j)

{
  corner[1][0]=i;
corner[1][1]=j;
mini_j=j;

}
}



}
}
}
}

cout<<"Hillary's coordinates"<<endl;
for(i=0;i<4;i++)
{

cout<<corner[i][0];
cout<<",";
    cout<<corner[i][1]<<endl;
}

}
//to find the corner points of the hole in the main image
void hillary_pic()
{
int i;
int j;
int Width=512;
int Height=512;
int counter=0;
for(i=1;i<Height;i++)
{
for(j=1;j<Width-1;j++)
{
if((hillary[i][j][0]==255)&&(hillary[i][j][1]==255)&&(hillary[i][j][2]==255))
{
if((hillary[i+1][j][0]==255)&&(hillary[i+11][j][1]==255)&&(hillary[i+1][j][2]==255))
{
if((hillary[i][j+1][0]==255)&&(hillary[i][j+1][1]==255)&&(hillary[i][j+1][2]==255))
{

if(counter==0)
{corner_hils[0][0]=i;
corner_hils[0][1]=j;
counter++;
cout<<"Coordinates in the picture"<<endl;
cout<<i;
cout<<",";
      cout<<j<<endl;

}
}
}

}
}
}
corner_hils[1][0]=100+corner_hils[0][0];
corner_hils[1][1]=corner_hils[0][1];
corner_hils[2][0]=corner_hils[1][0];
corner_hils[2][1]=100+corner_hils[1][1];
corner_hils[3][0]=100+corner_hils[2][0];
corner_hils[3][1]=corner_hils[2][1];



}
//To place the missing piece in the image and process the output by mean filter
void pic_fill()
{
int i;
int j;
double x;
double y;
double u;
double v;
float a,b,p,q;
int p1,q1;
unsigned char board[100][100][3];
float triangle_1[3][3]={{1.4646,0.3939,56.6414},{-0.3939,1.4646,296.1061},{0,0,1}};

float triangle_2[3][3]={{1.4646,0.3939,56.6414},{-0.3838,1.4545,296.1263},{0,0,1}};
for(i=0;i<100;i++)
    {
    for(j=0;j<100;j++)
    {
        x=(j)-(1.0/2);
        y=100-(i)+(1.0/2);

        if(i+j-99>0)
        {
             u=(triangle_1[0][0]*x)+(triangle_1[0][1]*y)+triangle_1[0][2];
             v=(triangle_1[1][0]*x)+(triangle_1[1][1]*y)+triangle_1[1][2];
             p=(500-v+(1.0/2));
             q=u+(1.0/2);
          p1=floor(p);
          q1=floor(q);
           b=p-p1;
           a=q-q1;




            board[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
            board[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
            board[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));


        }
        else
{

             u=(triangle_2[0][0]*x)+(triangle_2[0][1]*y)+triangle_2[0][2];
             v=(triangle_2[1][0]*x)+(triangle_2[1][1]*y)+triangle_2[1][2];
             p=(500-v+(1.0/2));
             q=u+(1.0/2);


            p1=floor(p);
          q1=floor(q);
           b=p-p1;
           a=q-q1;


           board[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
            board[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
            board[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));

    }
    }
    }

    int a1;
    int b1;
    int c;
    for(i=0;i<512;i++)
    {
    for(j=0;j<512;j++)
    {
        outImagedata[i][j][0]=hillary[i][j][0];
        outImagedata[i][j][1]=hillary[i][j][1];
        outImagedata[i][j][2]=hillary[i][j][2];
    }

    }
    for(i=0;i<100;i++)
    {
    for(j=0;j<100;j++)
    {
        a1=i+corner_hils[0][0];
        b1=j+corner_hils[0][1];
        outImagedata[a1][b1][0]=board[i][j][0];
         outImagedata[a1][b1][1]=board[i][j][1];
          outImagedata[a1][b1][2]=board[i][j][2];
    }
    }
       for(i=0;i<512;i++)
    {
    for(j=0;j<512;j++)
    {
        outImagedata_median[i][j][0]=outImagedata[i][j][0];
        outImagedata_median[i][j][1]=outImagedata[i][j][1];
        outImagedata_median[i][j][2]=outImagedata[i][j][2];
    }

    }

int window_height=0;
int window_width=0;
unsigned char arrange_red[9];
unsigned char  arrange_blue[9];
unsigned char arrange_green[9];
int extend=1;
int window=3;
for(i=corner_hils[0][0];i<corner_hils[1][0];i++)
{

    for(j=corner_hils[0][1];j<corner_hils[2][1];j++)
{
               c=0;
        for (window_height=i-extend;window_height<=i+extend;window_height++)
        {

        for (window_width=j-extend;window_width<=j+extend;window_width++)
            {

             arrange_red[c]=outImagedata[window_height][window_width][0];

            arrange_green[c]=outImagedata[window_height][window_width][1];

            arrange_blue[c]=outImagedata[window_height][window_width][2];
            c=c+1;




        }
       }
        sort(arrange_red,arrange_red+(window*window));

        outImagedata_median[i][j][0]=arrange_red[4];
           sort(arrange_blue,arrange_blue+(window*window));
        outImagedata_median[i][j][2]=arrange_blue[4];
             sort(arrange_green,arrange_green+(window*window));
        outImagedata_median[i][j][1]=arrange_green[4];
}

}

}
//to find the corner points of the missing piece in the piece.raw image
void trump_piece()
{
int i;
int j;
int Width=500;
int Height=500;
int mini_i=500;
int maxi=500;
int max_i=0;
for(i=260;i<=Height-1;i++)
{
for(j=1;j<Width-1;j++)
{
    if((Imagedata[i][j][0]!=255)&&(Imagedata[i][j][1]!=255)&&(Imagedata[i][j][2]!=255))
{

if((Imagedata[i-1][j][0]==255)&&(Imagedata[i-1][j][1]==255)&&(Imagedata[i-1][j][2]==255))
{
if((Imagedata[i][j-1][0]==255)&&(Imagedata[i][j-1][1]==255)&&(Imagedata[i][j-1][2]==255))
{
if((Imagedata[i+1][j][0]!=255)&&(Imagedata[i+1][j][1]!=255)&&(Imagedata[i+1][j][2]!=255)&&(Imagedata[i][j+1][0]!=255)&&(Imagedata[i][j+1][1]!=255)&&(Imagedata[i][j+1][2]!=255))
{
      if(i<mini_i)
{
corner_trump[3][0]=i;
corner_trump[3][1]=j;
}


}
}
}
if((Imagedata[i-1][j][0]!=255)&&(Imagedata[i-1][j][1]!=255)&&(Imagedata[i-1][j][2]!=255)&&(Imagedata[i][j+1][0]!=255)&&(Imagedata[i][j+1][1]!=255)&&(Imagedata[i][j+1][2]!=255)&&(Imagedata[i+1][j][0]==255)&&(Imagedata[i+1][j][1]==255)&&(Imagedata[i+1][j][2]==255))
{
    if((Imagedata[i][j-1][0]==255)&&(Imagedata[i][j-1][1]==255)&&(Imagedata[i][j-1][2]==255))
    {

if(i>max_i)

{
corner_trump[0][0]=i;
corner_trump[0][1]=j;
max_i=i;

}
}
}

if((Imagedata[i-1][j][0]!=255)&&(Imagedata[i-1][j][1]!=255)&&(Imagedata[i-1][j][2]!=255)&&(Imagedata[i][j+1][0]==255)&&(Imagedata[i][j+1][1]==255)&&(Imagedata[i][j+1][2]==255))
{
if((Imagedata[i+1][j][0]==255)&&(Imagedata[i+1][j][1]==255)&&(Imagedata[i+1][j][2]==255))
{
if((Imagedata[i][j-1][0]!=255)&&(Imagedata[i][j-1][1]!=255)&&(Imagedata[i][j-1][2]!=255))
{
if(j>maxi)

{
  corner_trump[1][0]=i;
corner_trump[1][1]=j;
maxi=j;


}
}
}
}
if((Imagedata[i-1][j][0]==255)&&(Imagedata[i-1][j][1]==255)&&(Imagedata[i-1][j][2]==255)&&(Imagedata[i][j+1][0]==255)&&(Imagedata[i][j+1][1]==255)&&(Imagedata[i][j+1][2]==255))
{
if((Imagedata[i+1][j][0]!=255)&&(Imagedata[i+1][j][1]!=255)&&(Imagedata[i+1][j][2]!=255))
{
if((Imagedata[i][j-1][0]!=255)&&(Imagedata[i][j-1][1]!=255)&&(Imagedata[i][j-1][2]!=255))
{
if(j<maxi)

{
  corner_trump[2][0]=i;
corner_trump[2][1]=j;
maxi=j;


}
}
}
}
}
}
}
cout<<"Trump's coordinates"<<endl;
for(i=0;i<4;i++)
{

cout<<corner_trump[i][0];
cout<<",";
    cout<<corner_trump[i][1]<<endl;
}
}
//-------------------------------------------------------------------------------------------------------
//to find the corner points of the hole in the main image
void trump_pic()
{
int i;
int j;
int Width=512;
int Height=512;
int counter=0;
for(i=1;i<Height;i++)
{
for(j=1;j<Width-1;j++)
{
if((trump[i][j][0]==255)&&(trump[i][j][1]==255)&&(trump[i][j][2]==255))
{
if((trump[i+1][j][0]==255)&&(trump[i+11][j][1]==255)&&(trump[i+1][j][2]==255))
{
if((trump[i][j+1][0]==255)&&(trump[i][j+1][1]==255)&&(trump[i][j+1][2]==255))
{

if(counter==0)
{
    corner_trump[0][0]=i;
corner_trump[0][1]=j;
counter++;
cout<<"Coordinates in the picture(trump)"<<endl;
cout<<i;
cout<<",";
      cout<<j<<endl;

}
}
}

}
}
}
corner_trump[1][0]=100+corner_trump[0][0];
corner_trump[1][1]=corner_trump[0][1];
corner_trump[2][0]=corner_trump[1][0];
corner_trump[2][1]=100+corner_trump[1][1];
corner_trump[3][0]=100+corner_trump[2][0];
corner_trump[3][1]=corner_trump[2][1];



}
//to place the  the missing piece in the main image and process it by median filter
void trump_fill()
{
    int i;
int j;
double x;
double y;
double u;
double v;
float a,b,p,q;
int p1,q1;
unsigned char board[100][100][3];
float triangle_1[3][3]={{-0.0606,-0.7576,383.6061},{  0.7576,-0.0707,136.9848},{0,0,1}};

float triangle_2[3][3]={{-0.0606,-0.7576,383.6061},{ 0.7475,-0.0606,136.9646},{0,0,1}};
for(i=0;i<100;i++)
    {
    for(j=0;j<100;j++)
    {
        x=(j)-(1.0/2);
        y=100-(i)+(1.0/2);

        if(i+j-99>0)
        {
             u=(triangle_1[0][0]*x)+(triangle_1[0][1]*y)+triangle_1[0][2];
             v=(triangle_1[1][0]*x)+(triangle_1[1][1]*y)+triangle_1[1][2];
             p=(500-v+(1.0/2));
             q=u+(1.0/2);
          p1=floor(p);
          q1=floor(q);
           b=p-p1;
           a=q-q1;




            board[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
            board[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
            board[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));



        }
        else
{

             u=(triangle_2[0][0]*x)+(triangle_2[0][1]*y)+triangle_2[0][2];
             v=(triangle_2[1][0]*x)+(triangle_2[1][1]*y)+triangle_2[1][2];
             p=(500-v+(1.0/2));
             q=u+(1.0/2);


            p1=floor(p);
          q1=floor(q);
           b=p-p1;
           a=q-q1;


           board[i][j][0]=floor((1-b)*((1-a)*Imagedata[p1][q1][0]+(a*Imagedata[p1][q1+1][0]))+b*((1-a)*(Imagedata[p1+1][q1][0])+a*(Imagedata[p1+1][q1+1][0])));
            board[i][j][1]=floor((1-b)*((1-a)*Imagedata[p1][q1][1]+(a*Imagedata[p1][q1+1][1]))+b*((1-a)*(Imagedata[p1+1][q1][1])+a*(Imagedata[p1+1][q1+1][1])));
            board[i][j][2]=floor((1-b)*((1-a)*Imagedata[p1][q1][2]+(a*Imagedata[p1][q1+1][2]))+b*((1-a)*(Imagedata[p1+1][q1][2])+a*(Imagedata[p1+1][q1+1][2])));



    }
    }
    }

    int a1;
    int b1;
    int c;
    for(i=0;i<512;i++)
    {
    for(j=0;j<512;j++)
    {
        outImagedata_trump[i][j][0]=trump[i][j][0];
        outImagedata_trump[i][j][1]=trump[i][j][1];
        outImagedata_trump[i][j][2]=trump[i][j][2];
    }

    }
    for(i=0;i<100;i++)
    {
    for(j=0;j<100;j++)
    {
        a1=i+corner_trump[0][0];
        b1=j+corner_trump[0][1];
        outImagedata_trump[a1][b1][0]=board[i][j][0];
         outImagedata_trump[a1][b1][1]=board[i][j][1];
          outImagedata_trump[a1][b1][2]=board[i][j][2];
    }
    }
       for(i=0;i<512;i++)
    {
    for(j=0;j<512;j++)
    {
        outImagedata_median_trump[i][j][0]=outImagedata_trump[i][j][0];
        outImagedata_median_trump[i][j][1]=outImagedata_trump[i][j][1];
        outImagedata_median_trump[i][j][2]=outImagedata_trump[i][j][2];
    }

    }

int window_height=0;
int window_width=0;
unsigned char arrange_red[25];
unsigned char  arrange_blue[25];
unsigned char arrange_green[25];
int extend=2;
int window=5;
for(i=corner_trump[0][0];i<corner_trump[1][0];i++)
{

    for(j=corner_trump[0][1];j<corner_trump[2][1];j++)
{
               c=0;
        for (window_height=i-extend;window_height<=i+extend;window_height++)
        {

        for (window_width=j-extend;window_width<=j+extend;window_width++)
            {

             arrange_red[c]=outImagedata_trump[window_height][window_width][0];

            arrange_green[c]=outImagedata_trump[window_height][window_width][1];

            arrange_blue[c]=outImagedata_trump[window_height][window_width][2];
            c=c+1;




        }
       }
        sort(arrange_red,arrange_red+(window*window));

        outImagedata_median_trump[i][j][0]=arrange_red[4];
           sort(arrange_blue,arrange_blue+(window*window));
        outImagedata_median_trump[i][j][2]=arrange_blue[4];
             sort(arrange_green,arrange_green+(window*window));
        outImagedata_median_trump[i][j][1]=arrange_green[4];
}

}

}

int main()
{
int Height=512;
int Width=512;
int Height_piece=500;
int Width_piece=500;
int Bytesperpixel=3;
FILE *file;
if (!(file=fopen("piece.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(Imagedata, sizeof(unsigned char),Height_piece*Width_piece*Bytesperpixel, file);
fclose(file);
if (!(file=fopen("Hillary.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(hillary, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
if (!(file=fopen("Trump.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(trump, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
hillary_piece();
hillary_pic();
pic_fill();

trump_piece();
trump_pic();
trump_fill();

if (!(file=fopen("filled_hillary.raw","wb"))) {
    cout << "Cannot open file: " << endl;
    exit(1);
}

fwrite(outImagedata, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);


if (!(file=fopen("median_hillary.raw","wb"))) {
    cout << "Cannot open file: " << endl;
    exit(1);
}

fwrite(outImagedata_median, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
if (!(file=fopen("filled_trump.raw","wb"))) {
    cout << "Cannot open file: " << endl;
    exit(1);
}

fwrite(outImagedata_trump, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);


if (!(file=fopen("median_trump.raw","wb"))) {
    cout << "Cannot open file: " << endl;
    exit(1);
}

fwrite(outImagedata_median_trump, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);

return 0;
}

//---------------------------------------------------------------------------------------//
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/
unsigned char Imagedata[648][972][3];//input field image
unsigned char tartans[146][350][3];//input tartans image
unsigned char trojans[197][350][3];//input trojan image
unsigned char tartans_copied[648][972][3];
unsigned char trojans_copied[648][972][3];
int Bytesperpixel=3;

    int Height=648;
int Width=972;
   int Height_1=146;
int Width_1=350;

using namespace std;
void tartans_overlap()
{
    int k;
       FILE *file;
     double x;
          double y;
//Sovled the equation via matlab to obtain the transformation matrix
    double H[3][3]={{ 0.0627,  0.8263,  -62.0362},{-0.5650,  0.3868,   285.3184},{0.000,-0.0024,1}};
    double x1;
    double y1;
    double X;
    double Y;
    double p;
    double q;
    double z;
    unsigned char r,g,b1;
    float a,b;
    int p1,q1;

int i;int j;

  for(i=0;i<648;i++)
  {
      for(j=0;j<972;j++)
      {
            x=j+(1.0/2);
            y=648-i-(1.0/2);

if(((y+0.0758*x)>=75.57)&&((y-1.45*(x))>=-733.99)&&((y+0.045*(x))<=246.93)&&((y-0.76*(x))<=-189.8))
{

          x1=(H[0][0]*x)+H[0][1]*y+H[0][2];
          y1=(H[1][0]*x)+H[1][1]*y+H[1][2];
           z=(H[2][0]*x)+H[2][1]*y+H[2][2];

X=(1.0*x1/z);
Y=(1.0*y1/z);

            q=X-(1.0/2);
            p=146-Y-(1.0/2);
            p1=floor(p);
            q1=floor(q);
                b=p-p1;
                a=q-q1;
//Bilinear interpolation

                r=(unsigned char)floor((1-b)*((1-a)*tartans[p1][q1][0]+(a*tartans[p1][q1+1][0]))+b*((1-a)*(tartans[p1+1][q1][0])+a*(tartans[p1+1][q1+1][0])));
                g=(unsigned char)floor((1-b)*((1-a)*tartans[p1][q1][1]+(a*tartans[p1][q1+1][1]))+b*((1-a)*(tartans[p1+1][q1][1])+a*(tartans[p1+1][q1+1][1])));
                b1=(unsigned char)floor((1-b)*((1-a)*tartans[p1][q1][2]+(a*tartans[p1][q1+1][2]))+b*((1-a)*(tartans[p1+1][q1][2])+a*(tartans[p1+1][q1+1][2])));

int t;

            if((r>0))
            {//Image overlay
                tartans_copied[i][j][0]=0.5*(unsigned char)r+0.5*Imagedata[i][j][0];
                tartans_copied[i][j][1]=0.5*(unsigned char)g+0.5*Imagedata[i][j][1];
                tartans_copied[i][j][2]=0.5*(unsigned char)b1+0.5*Imagedata[i][j][2];;

            }




      }

  }




}

 if (!(file=fopen("tartans_output.raw","wb"))) {
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fwrite(tartans_copied, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
	fclose(file);

}
void trojans_overlap()
{
    int k;
       FILE *file;
     double x;
          double y;

    double H[3][3]={{ 0.0627,  0.8263,  -62.0362},{ -0.7637,   0.5233,   385.4959},{0.000,-0.0024,1}};
    double x1;
    double y1;
    double X;
    double Y;
    double p;
    double q;
    double z;
    unsigned char r,g,b1;
    float a,b;
    int p1,q1;

int i;int j;

  for(i=0;i<648;i++)
  {
      for(j=0;j<972;j++)
      {
            x=j+(1.0/2);
            y=648-i-(1.0/2);

if(((y+0.0758*x)>=75.57)&&((y-1.45*(x))>=-733.99)&&((y+0.045*(x))<=246.93)&&((y-0.76*(x))<=-189.8))
{

          x1=(H[0][0]*x)+H[0][1]*y+H[0][2];
          y1=(H[1][0]*x)+H[1][1]*y+H[1][2];
           z=(H[2][0]*x)+H[2][1]*y+H[2][2];

X=(1.0*x1/z);
Y=(1.0*y1/z);

            q=X-(1.0/2);
            p=197-Y-(1.0/2);
            p1=floor(p);
            q1=floor(q);
                b=p-p1;
                a=q-q1;
//Bilinear interpolation

                r=(unsigned char)floor((1-b)*((1-a)*trojans[p1][q1][0]+(a*trojans[p1][q1+1][0]))+b*((1-a)*(trojans[p1+1][q1][0])+a*(trojans[p1+1][q1+1][0])));
                g=(unsigned char)floor((1-b)*((1-a)*trojans[p1][q1][1]+(a*trojans[p1][q1+1][1]))+b*((1-a)*(trojans[p1+1][q1][1])+a*(trojans[p1+1][q1+1][1])));
                b1=(unsigned char)floor((1-b)*((1-a)*trojans[p1][q1][2]+(a*trojans[p1][q1+1][2]))+b*((1-a)*(trojans[p1+1][q1][2])+a*(trojans[p1+1][q1+1][2])));

int t;
t=(int)g;
//Image overlay
            if((t<100))
            {
                trojans_copied[i][j][0]=0.5*(unsigned char)r+0.5*Imagedata[i][j][0];
                trojans_copied[i][j][1]=0.5*(unsigned char)g+0.5*Imagedata[i][j][1];
                trojans_copied[i][j][2]=0.5*(unsigned char)b1+0.5*Imagedata[i][j][2];;

            }




      }

  }




}

 if (!(file=fopen("trojans_output.raw","wb"))) {
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fwrite(trojans_copied, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
	fclose(file);

}
int main()
{

    FILE *file;
    int i,j;
    if (!(file=fopen("field.raw","rb")))
        {
    cout << "Cannot open file: " <<endl;
    exit(1);
}

fread(Imagedata, sizeof(unsigned char),Height*Width*Bytesperpixel, file);
fclose(file);
  for(i=0;i<Height;i++)
  {
      for(j=0;j<Width;j++)

            {
                tartans_copied[i][j][0]=Imagedata[i][j][0];
                trojans_copied[i][j][0]=Imagedata[i][j][0];
                tartans_copied[i][j][1]=Imagedata[i][j][1];
                trojans_copied[i][j][1]=Imagedata[i][j][1];
                tartans_copied[i][j][2]=Imagedata[i][j][2];
                trojans_copied[i][j][2]=Imagedata[i][j][2];
            }
  }
if (!(file=fopen("tartans.raw","rb"))) {
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fread(tartans, sizeof(unsigned char),Height_1*Width_1*Bytesperpixel, file);
	fclose(file);
	if (!(file=fopen("trojans.raw","rb"))) {
		cout << "Cannot open file: " << endl;
		exit(1);
	}

	fread(trojans, sizeof(unsigned char),197*Width_1*Bytesperpixel, file);
	fclose(file);

tartans_overlap();
trojans_overlap();

return 0;
}
-----------------------------------------------------------------------------------------
Homework 2:
Ordered Dithering
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/

using namespace std;

unsigned char F[512][512];

unsigned char fourlevels[512][512];
unsigned char outputimage_2[512][512];
unsigned char outputimage_8[512][512];
unsigned char outputimage_4[512][512];
unsigned char outputimage_A_4[512][512];
int Height=512;
int Width=512;

int Bayer_2[2][2];
int Bayer_4[4][4];
int Bayer_8[8][8];
//I2

void Bayer_2_creation()
{

Bayer_2[0][0]=0;
Bayer_2[0][1]=2;
Bayer_2[1][0]=3;
Bayer_2[1][1]=1;
}
//Applying I2 to the image
void Bayer_2_action()
{


   float threshold_2[2][2];
   double G_2[512][512];
   int i;
   int j;

Bayer_2_creation();
for(i=0;i<2;i++)
{
    for(j=0;j<2;j++)
    {
        threshold_2[i][j]=255*(((1.0*Bayer_2[i][j])+0.5)/4);
    }
}
unsigned char check;
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        check=(unsigned char)threshold_2[i%2][j%2];

        if(F[i][j]>check)
        {
            G_2[i][j]=1;
        }
        else
            {
                G_2[i][j]=0;
            }
            }
}

for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        outputimage_2[i][j]=(unsigned char)((G_2[i][j])*255);
    }
}


}
// creating I4
void Bayer_4_creation()
{

int i;
int j;
Bayer_2_creation();
for(i=0;i<4;i++)
{
    for(j=0;j<4;j++)
    {
        if(i<2 && j<2)
        {
             Bayer_4[i][j]=4*(Bayer_2[i][j]);
        }
        else if(i<2 && 2<=j)
        {
             Bayer_4[i][j]=4*(Bayer_2[i][j%2])+2;
        }
         else if(2<=i && j<2)
        {
             Bayer_4[i][j]=4*(Bayer_2[i%2][j])+3;
        }
        else
        {
             Bayer_4[i][j]=4*(Bayer_2[i%2][j%2])+1;
        }
    }
}
}
//Applying I4 to the image
void Bayer_4_action()
{
    Bayer_4_creation();
   float threshold_4[4][4];
   double G_4[512][512];
   int i;
   int j;
   for(i=0;i<4;i++)
{
    for(j=0;j<4;j++)
    {
        threshold_4[i][j]=255*(((1.0*Bayer_4[i][j])+0.5)/16);
    }

    }
unsigned char check;
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        check=(unsigned char)threshold_4[i%4][j%4];
             if(F[i][j]>check)
             {
                  G_4[i][j]=1;
             }
             else
            {
                G_4[i][j]=0;
            }
    }
}
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        outputimage_4[i][j]=(unsigned char)((G_4[i][j])*255);
    }
}



}
//Creaing I8
void Bayer_8_creation()
{
Bayer_4_creation();
int i;
int j;
//**Applying I8(i,j) to the image**(Bayer(8*8) Dithering matrix)**//////////////////////////

for(i=0;i<8;i++)
{
    for(j=0;j<8;j++)
    {
        if(i<4 && j<4)
        {
             Bayer_8[i][j]=4*(Bayer_4[i][j]);
        }
        else if(i<4 && 4<=j)
        {
             Bayer_8[i][j]=4*(Bayer_4[i][j%4])+2;
        }
         else if(4<=i && j<4)
        {
             Bayer_8[i][j]=4*(Bayer_4[i%4][j])+3;
        }
        else
        {
             Bayer_8[i][j]=4*(Bayer_4[i%4][j%4])+1;
        }
    }
}

}
void Bayer_8_action()
{
    Bayer_8_creation();
    int i;
    int j;
    double G_8[512][512];
   float threshold_8[8][8];
for(i=0;i<8;i++)
{
    for(j=0;j<8;j++)
    {
        threshold_8[i][j]=255*(((1.0*Bayer_8[i][j])+0.5)/64);


    }
}
unsigned char check;
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        check=(unsigned char)threshold_8[i%8][j%8];
             if(F[i][j]>check)
             {
                  G_8[i][j]=1;
             }
             else
            {
                G_8[i][j]=0;
            }
    }
}
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
outputimage_8[i][j]=(unsigned char)((G_8[i][j])*255);
    }
}


}

void A_4_action()
{
    double A_4[512][512];
    int A_4_mat[4][4];
    int i;
    int j;
    //Entering the A_4 matrix

A_4_mat[0][0]=14;
A_4_mat[0][1]=10;
A_4_mat[0][2]=11;
A_4_mat[0][3]=15;

A_4_mat[1][0]=9;
A_4_mat[1][1]=3;
A_4_mat[1][2]=0;
A_4_mat[1][3]=4;

A_4_mat[2][0]=8;
A_4_mat[2][1]=2;
A_4_mat[2][2]=1;
A_4_mat[2][3]=5;

A_4_mat[3][0]=13;
A_4_mat[3][1]=7;
A_4_mat[3][2]=6;
A_4_mat[3][3]=12;
float threshold_A4[4][4];
for(i=0;i<4;i++)
{
    for(j=0;j<4;j++)
    {

        threshold_A4[i][j]=255*(((1.0*A_4_mat[i][j])+0.5)/16);


    }
}
unsigned char check;
for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        check=(unsigned char)threshold_A4[i%4][j%4];
             if(F[i][j]>check)
             {
                  A_4[i][j]=1;
             }
             else
            {
                A_4[i][j]=0;
            }
    }
}

for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
        outputimage_A_4[i][j]=(unsigned char)((A_4[i][j])*255);
    }
}



}



int main(int argc, char *argv[])
{
    FILE *file;
    if (!(file=fopen(argv[1],"rb")))
        {
    cout << "Cannot open file: " <<endl;
    exit(1);
}
fread(F, sizeof(unsigned char),Height*Width, file);
fclose(file);
cout<<" Reading the image"<<endl;

//**Applying I2(i,j) to the image**(Bayer(2*2) Dithering matrix**//////////////////////////
Bayer_2_action();
Bayer_4_action();
Bayer_8_action();
A_4_action();
//Quantizing image as a function of Four levels
  int i;
     int j;
     int t;
     int u;
     for(i=0;i<512;i++)
{
    for(j=0;j<512;j++)
    {
 u=(int)F[i][j];
             if(u<45)
             {
                  t=0;
             }
             else if(u<90)
            {
                t=85;
            }
             else if(u<170)
            {
               t=170;
            }
            else
            {
                t=255;
            }
          fourlevels[i][j]=(unsigned char)t;



    }
}

//SAVING THE IMAGE MATRIX AS OUTPUT FILES.
if (!(file=fopen("outputman_bayer_2.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outputimage_2, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output corresponding to 2*2 bayer_indices_matrix is saved. "<<endl;


if (!(file=fopen("outputman_bayer_8.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
                   exit(1);
            }
fwrite(outputimage_8, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);

cout <<"\n The output corresponding to 8*8 bayer_indices_matrix is saved. "<<endl;

if (!(file=fopen("outputman_bayer_4.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outputimage_4, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output corresponding to 4*4 bayer_indices_matrix is saved. "<<endl;

if (!(file=fopen("outputman_A_4_Matrix.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outputimage_A_4, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output corresponding to 4*4 A_4_matrix is saved. "<<endl;
if (!(file=fopen("outputman_fourlevels.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(fourlevels, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output  is saved. "<<endl;

////////////////////////////////////////////////////*/
return 0;
}
========================================================================================
Error Diffusion:
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>
/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017

*/

using namespace std;
int Height=512;
int Width=512;
FILE *file;

float F_floyd[514][514];
float  F_jarvis[516][516];
unsigned char imagedata[512][512];
unsigned char outimagedata_floyd[512][512];
unsigned char outimagedata_jarvis[512][512];
unsigned char outimagedata_stucki[512][512];

//Expanding the image
void expand(int extend)
{
      int i;
    int j;


  int new_Height=Height+extend;
  int new_Width=Height+extend;
    unsigned char imagedata_new[new_Height][new_Width];

 for(i=0;i<Height;i++)
      {
          for(j=0;j<Width;j++)
          {

                imagedata_new[i+extend][j+extend]=imagedata[i][j];

          }
      }


      for(j=0;j<Width;j++)
          {

                  int e;
                  for(e=extend-1;e>0;e--)
                  {
                imagedata_new[e][j+extend]=imagedata[0][j];
                 imagedata_new[(Height+extend)+e][j+extend]=imagedata[0][j];


                  }

          }
          cout<<"copied2"<<endl;

           for(i=0;i<new_Height;i++)
          {

                  int e;
                  for(e=extend-1;e>0;e--)
                  {
                imagedata_new[i][e]=imagedata[i][extend];
                 imagedata_new[i][(Width+extend)+e]=imagedata[i][Width+extend-1];


                  }

          }

int data;

if(extend==1)
{

 for(int i=0;i<new_Height;i++)
 {
    for(int j=0;j<new_Width;j++)
 {
     data=(int)imagedata_new[i][j];

  F_floyd[i][j]=(1.0*data)/255;
 }
 }
}
else if(extend==2)
{

 for(int i=0;i<new_Height;i++)
 {
    for(int j=0;j<new_Width+1;j++)
 {
     data=(int)imagedata_new[i][j];

  F_jarvis[i][j]=(1.0*data)/255;

 }
 }
}

}

//Applying Floyd;s Algorithm
void floyd()
{
   expand(1);
   int i;
   int j;
   float quant_error=0;
float G[512][512];
float F[514][514];
for(i=0;i<Height+1;i++)
{
        for(j=0;j<Width+1;j++)
        {
           F[i][j]=F_floyd[i][j];

        }


        }
for(i=1;i<Height+1;i++)
{
    if(i%2==1)
    {
        for(j=1;j<Width+1;j++)
        {
            if(F[i][j]>0.5)
            {
                G[i-1][j-1]=1;
            }
            else
            {
                G[i-1][j-1]=0;
            }
            quant_error=F[i][j]-G[i-1][j-1];





            F[i][j+1]=F[i][j+1]+((7.0/16)*quant_error);
            F[i+1][j-1]=F[i+1][j-1]+((3.0/16)*quant_error);
            F[i+1][j]=F[i+1][j]+((5.0/16)*quant_error);
            F[i+1][j+1]=F[i+1][j+1]+((1.0/16)*quant_error);





     }
    }

    else if(i%2==0)

     {
         for(j=Width;j>0;j--)
        {
            if(F[i][j]>0.5)
            {
                G[i-1][j-1]=1;
            }
            else
            {
                G[i-1][j-1]=0;
            }
            quant_error=F[i][j]-G[i-1][j-1];


            F[i][j-1]=F[i][j-1]+((7.0/16)*quant_error);
            F[i+1][j-1]=F[i+1][j-1]+((1.0/16)*quant_error);
            F[i+1][j]=F[i+1][j]+((5.0/16)*quant_error);
            F[i+1][j+1]=F[i+1][j+1]+((3.0/16)*quant_error);


        }
     }
}


 for(i=0;i<Height;i++)
 {
    for(j=0;j<Width;j++)
 {
  outimagedata_floyd[i][j]=(unsigned char)(255.0*G[i][j]);

 }

 }
cout<<"copied7"<<endl;

}


//Applying jarvis;s Algorithm
void jarvis()
{
expand(2);

  int i;
  int j;

float quant_error=0;
float G[512][512];
float F[516][516];
for(i=0;i<Height+2;i++)
{
        for(j=0;j<Width+2;j++)
        {
           F[i][j]=F_jarvis[i][j];

        }


        }
for(i=2;i<Height+2;i++)
{
    if(i%2==0)
    {
        for(j=2;j<Width+2;j++)
        {
            if(F[i][j]>0.5)
            {
                G[i-2][j-2]=1;
            }
            else
            {
                G[i-2][j-2]=0;
            }
            quant_error=F[i][j]-G[i-2][j-2];


            F[i][j+1]=F[i][j+1]+(7.0/48)*quant_error;
            F[i][j+2]=F[i][j+2]+(5.0/48)*quant_error;

             F[i+1][j-2]=F[i+1][j-2]+(3.0/48)*quant_error;
            F[i+1][j-1]=F[i+1][j-1]+(5.0/48)*quant_error;
            F[i+1][j]=F[i+1][j]+(7.0/48)*quant_error;
            F[i+1][j+1]=F[i+1][j+1]+(5.0/48)*quant_error;
            F[i+1][j+2]=F[i+1][j+2]+(3.0/48)*quant_error;

            F[i+2][j-2]=F[i+2][j-2]+(1.0/48)*quant_error;
            F[i+2][j-1]=F[i+2][j-1]+(3.0/48)*quant_error;
            F[i+2][j]=F[i+2][j]+(5.0/48)*quant_error;
            F[i+2][j+1]=F[i+2][j+1]+(3.0/48)*quant_error;
            F[i+2][j+2]=F[i+2][j+2]+(1.0/48)*quant_error;


        }
    }
     if(i%2==1)
     {
         for(j=Width+1;j>=2;j--)
        {
            if(F[i][j]>0.5)
            {
                G[i-2][j-2]=1;
            }
            else
            {
                G[i-2][j-2]=0;
            }
            quant_error=F[i][j]-G[i-2][j-2];

               F[i][j-1]=F[i][j-1]+(7.0/48)*quant_error;
               F[i][j-2]=F[i][j-2]+(5.0/48)*quant_error;

            F[i+1][j-2]=F[i+1][j-2]+(3.0/48)*quant_error;
            F[i+1][j-1]=F[i+1][j-1]+(5.0/48)*quant_error;
            F[i+1][j]=F[i+1][j]+(7.0/48)*quant_error;
            F[i+1][j+1]=F[i+1][j+1]+(5.0/48)*quant_error;
            F[i+1][j+2]=F[i+1][j+2]+(3.0/48)*quant_error;

            F[i+2][j-2]=F[i+2][j-2]+(1.0/48)*quant_error;
            F[i+2][j-1]=F[i+2][j-1]+(3.0/48)*quant_error;
            F[i+2][j]=F[i+2][j]+(5.0/48)*quant_error;
            F[i+2][j+1]=F[i+2][j+1]+(3.0/48)*quant_error;
            F[i+2][j+2]=F[i+2][j+2]+(1.0/48)*quant_error;



        }
     }

}
      for(i=0;i<Height;i++)
 {
    for(j=0;j<Width;j++)
 {
  outimagedata_jarvis[i][j]=(unsigned char)(255.0*G[i][j]);

 }
 }

 if (!(file=fopen("outputman_jarvis.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outimagedata_jarvis, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output of jarvis error diffusion algorithm  is saved. "<<endl;





}
//Applying Stucki;s Algorithm
void stucki()
{

int i;
int j;
float quant_error=0;
float G[512][512];
float F[516][516];
for(i=0;i<Height+2;i++)
{
        for(j=0;j<Width+2;j++)
        {
           F[i][j]=F_jarvis[i][j];

        }


        }

for(i=2;i<Height+2;i++)
{
    if(i%2==0)
    {
        for(j=2;j<Width+2;j++)
        {
            if(F[i][j]>0.5)
            {
                G[i-2][j-2]=1;
            }
            else
            {
                G[i-2][j-2]=0;
            }
            quant_error=F[i][j]-G[i-2][j-2];


            F[i][j+1]=F[i][j+1]+(8.0/42)*quant_error;
            F[i][j+2]=F[i][j+2]+(4.0/42)*quant_error;

             F[i+1][j-2]=F[i+1][j-2]+(2.0/42)*quant_error;
            F[i+1][j-1]=F[i+1][j-1]+(4.0/42)*quant_error;
            F[i+1][j]=F[i+1][j]+(8.0/42)*quant_error;
            F[i+1][j+1]=F[i+1][j+1]+(4.0/42)*quant_error;
            F[i+1][j+2]=F[i+1][j+2]+(2.0/42)*quant_error;

            F[i+2][j-2]=F[i+2][j-2]+(1.0/42)*quant_error;
            F[i+2][j-1]=F[i+2][j-1]+(2.0/42)*quant_error;
            F[i+2][j]=F[i+2][j]+(4.0/42)*quant_error;
            F[i+2][j+1]=F[i+2][j+1]+(2.0/42)*quant_error;
            F[i+2][j+2]=F[i+2][j+2]+(1.0/48)*quant_error;


        }
    }
     if(i%2==1)
     {
         for(j=Width+1;j>=2;j--)
        {
            if(F[i][j]>0.5)
            {
                G[i-2][j-2]=1;
            }
            else
            {
                G[i-2][j-2]=0;
            }
            quant_error=F[i][j]-G[i-2][j-2];


            F[i][j-1]=F[i][j-1]+(8.0/42)*quant_error;
            F[i][j-2]=F[i][j-2]+(4.0/42)*quant_error;

             F[i+1][j-2]=F[i+1][j-2]+(2.0/42)*quant_error;
            F[i+1][j-1]=F[i+1][j-1]+(4.0/42)*quant_error;
            F[i+1][j]=F[i+1][j]+(8.0/42)*quant_error;
            F[i+1][j+1]=F[i+1][j+1]+(4.0/42)*quant_error;
            F[i+1][j+2]=F[i+1][j+2]+(2.0/42)*quant_error;

            F[i+2][j-2]=F[i+2][j-2]+(1.0/42)*quant_error;
            F[i+2][j-1]=F[i+2][j-1]+(2.0/42)*quant_error;
            F[i+2][j]=F[i+2][j]+(4.0/42)*quant_error;
            F[i+2][j+1]=F[i+2][j+1]+(2.0/42)*quant_error;
            F[i+2][j+2]=F[i+2][j+2]+(1.0/48)*quant_error;




        }
     }

}

      for(i=0;i<Height;i++)
 {
    for(j=0;j<Width;j++)
 {
  outimagedata_stucki[i][j]=(unsigned char)(255.0*G[i][j]);

 }
 }

if (!(file=fopen("outputman_stucki.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outimagedata_stucki, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output of stucki error diffusion algorithm  is saved. "<<endl;

}

int main(int argc, char *argv[])
{
    FILE *file;
    if (!(file=fopen(argv[1],"rb")))
        {
    cout << "Cannot open file: " <<endl;
    exit(1);
}


fread(imagedata, sizeof(unsigned char),Height*Width, file);
fclose(file);
cout<<" Reading the image"<<endl;

floyd();
jarvis();
stucki();

if (!(file=fopen("outputman_floyd.raw","wb")))
            {
                cout << "Cannot open file: "  << endl;
    exit(1);
            }
fwrite(outimagedata_floyd, sizeof(unsigned char), Height*Width, file);//saving the image in row formay
fclose(file);
cout <<"\n The output of floyd error diffusion algorithm  is saved. "<<endl;





////////////////////////////////////////////////////*/
return 0;
}




Homework 3:
Shrinking 
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>

/*
1)Name:Sahana Venkatesh (2)USC ID Number:6643244225 (3)USC Email:sahaave@usc.edu (4)Submission Date :2/26/2017
*/
using namespace std;

int Height=480;
int Width=480;
unsigned char Imagedata_notbin[480][480];
unsigned char previous[482][482];
int squares[19];


int OutImagedata[480][480];
int OutImagedata_final[480][480];
int Imagedata[482][482];
int Shrink[10][3][3]=
{{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}}};




int Shrink_1[4][3][3]={{{0,0,1},{0,1,0},{0,0,0}},
               {{1,0,0},{0,1,0},{0,0,0}},
               {{0,0,0},{0,1,0},{1,0,0}},
               {{0,0,0},{0,1,0},{0,0,1}}};

int Shrink_2[4][3][3]={{{0,0,0},{0,1,1},{0,0,0}},
               {{0,1,0},{0,1,0},{0,0,0}},
               {{0,0,0},{1,1,0},{0,0,0}},
               {{0,0,0},{0,1,0},{0,1,0}}};

int Shrink_3[8][3][3]={{{0,0,1},{0,1,1},{0,0,0}},
               {{0,1,1},{0,1,0},{0,0,0}},
               {{1,1,0},{0,1,0},{0,0,0}},
               {{1,0,0},{1,1,0},{0,0,0}},
               {{0,0,0},{1,1,0},{1,0,0}},
               {{0,0,0},{0,1,0},{1,1,0}},
               {{0,0,0},{0,1,0},{0,1,1}},
               {{0,0,0},{0,1,1},{0,0,1}}};


int Shrink_4[4][3][3]={{{0,0,1},{0,1,1},{0,0,1}},
               {{1,1,1},{0,1,0},{0,0,0}},
               {{1,0,0},{1,1,0},{1,0,0}},
               {{0,0,0},{0,1,0},{1,1,1}}};



int Shrink_5[4][3][3]={{{1,1,0},{0,1,1},{0,0,0}},
               {{0,1,0},{0,1,1},{0,0,1}},
               {{0,1,1},{1,1,0},{0,0,0}},
               {{0,0,1},{0,1,1},{0,1,0}}};


int Shrink_51[4][3][3]={{{0,1,1},{0,1,1},{0,0,0}},
               {{1,1,0},{1,1,0},{0,0,0}},
               {{0,0,0},{1,1,0},{1,1,0}},
               {{0,0,0},{0,1,1},{0,1,1}}};


int Shrink_61[8][3][3]={{{1,1,1},{0,1,1},{0,0,0}},

               {{0,1,1},{0,1,1},{0,0,1}},

               {{1,1,1},{1,1,0},{0,0,0}},

               {{1,1,0},{1,1,0},{1,0,0}},

               {{1,0,0},{1,1,0},{1,1,0}},

               {{0,0,0},{1,1,0},{1,1,1}},

               {{0,0,0},{0,1,1},{1,1,1}},

               {{0,0,1},{0,1,1},{0,1,1}}};


int Shrink_6[2][3][3]={{{1,1,0},{0,1,1},{0,0,1}},
               {{0,1,1},{1,1,0},{1,0,0}}};

int Shrink_7[4][3][3]={{{1,1,1},{0,1,1},{0,0,1}},
               {{1,1,1},{1,1,0},{1,0,0}},
               {{1,0,0},{1,1,0},{1,1,1}},
               {{0,0,1},{0,1,1},{1,1,1}}};

int Shrink_8[4][3][3]={{{0,1,1},{0,1,1},{0,1,1}},
               {{1,1,1},{1,1,1},{0,0,0}},
               {{1,1,0},{1,1,0},{1,1,0}},
               {{0,0,0},{1,1,1},{1,1,1}}};

int Shrink_9[8][3][3]=
               {{{1,1,1},{0,1,1},{0,1,1}},
               {{0,1,1},{0,1,1},{1,1,1}},
               {{1,1,1},{1,1,1},{1,0,0}},
               {{1,1,1},{1,1,1},{0,0,1}},
               {{1,1,1},{1,1,0},{1,1,0}},
              {{1,1,0},{1,1,0},{1,1,1}},
               {{1,0,0},{1,1,1},{1,1,1}},
                {{0,0,1},{1,1,1},{1,1,1}}};


int Shrink_10[4][3][3]=
              {{{1,1,1},{0,1,1},{1,1,1}},
               {{1,1,1},{1,1,1},{1,0,1}},
               {{1,1,1},{1,1,0},{1,1,1}},
               {{1,0,1},{1,1,1},{1,1,1}}};

int Mask[100][3][3]=
{{{0,0,1},{0,1,0},{0,0,0}},
{{1,0,0},{0,1,0},{0,0,0}},

{{0,0,0},{0,1,0},{0,1,0}},

{{0,0,0},{0,1,1},{0,0,0}},//Single-4-connection//

{{0,0,1},{0,1,1},{0,0,0}},
{{0,1,1},{0,1,0},{0,0,0}},
{{1,1,0},{0,1,0},{0,0,0}},
{{1,0,0},{1,1,0},{0,0,0}},
{{0,0,0},{1,1,0},{1,0,0}},
{{0,0,0},{0,1,0},{1,1,0}},
{{0,0,0},{0,1,0},{0,1,1}},
{{0,0,0},{0,1,1},{0,0,1}},//L-cluster

{{0,1,1},{1,1,0},{0,0,0}},
{{1,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{0,1,1},{0,0,1}},
{{0,0,1},{0,1,1},{0,1,0}},//4-connected-offeset

{{0,0,1},{0,1,1},{1,0,0}},
{{0,1,1},{0,1,0},{1,0,0}},
{{0,1,1},{0,1,1},{1,0,0}},

{{1,0,0},{1,1,0},{0,0,1}},
{{1,1,0},{0,1,0},{0,0,1}},
{{1,1,0},{1,1,0},{0,0,1}},

{{0,0,1},{0,1,0},{1,1,0}},
{{0,0,1},{1,1,0},{1,0,0}},
{{0,0,1},{1,1,0},{1,1,0}},

{{1,0,0},{0,1,0},{0,1,1}},
{{1,0,0},{0,1,1},{0,0,1}},
{{1,0,0},{0,1,1},{0,1,1}},//Spur-corner-cluster

{{1,1,0},{1,1,0},{0,0,0}},
{{1,1,1},{1,1,1},{1,1,1}},//Corner-Cluster

{{0,1,0},{1,1,1},{0,0,0}},
{{1,1,0},{1,1,1},{1,0,0}},

{{0,1,1},{1,1,1},{0,0,1}},

{{0,0,0},{1,1,1},{0,1,0}},
{{0,0,1},{1,1,1},{0,1,1}},

{{1,0,0},{1,1,1},{1,1,0}},

{{0,1,0},{1,1,0},{0,1,0}},
{{1,1,1},{1,1,0},{0,1,0}},

{{0,1,0},{1,1,0},{1,1,1}},

{{0,1,0},{0,1,1},{0,1,0}},
{{0,1,0},{0,1,1},{1,1,1}},

{{1,1,1},{0,1,1},{0,1,0}},//tee-branch

{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{0,1,0}},
{{1,0,1},{0,1,0},{0,1,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,1,0}},
{{1,0,1},{0,1,0},{1,1,1}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,1},{0,1,0}},
{{1,1,1},{1,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,1},{1,1,0}},

{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,1},{1,0,0}},
{{1,0,0},{0,1,1},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,1},{1,0,0}},
{{1,0,1},{0,1,1},{1,0,1}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,0}},
{{1,1,0},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,1},{1,1,0},{1,1,1}},

{{0,0,1},{0,1,0},{1,0,1}},
{{0,1,0},{0,1,0},{1,0,1}},
{{0,1,1},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,1,0},{0,1,0},{1,0,1}},
{{1,1,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}},

{{0,0,1},{0,1,0},{1,0,1}},

{{0,0,1},{1,1,0},{0,0,1}},
{{0,0,1},{1,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{1,1,0},{0,0,1}},
{{1,0,1},{1,1,0},{1,0,1}},
{{0,1,1},{0,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{0,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,1,1}},//VEE BRANCH

{{0,1,0},{0,1,1},{1,0,0}},
{{1,1,0},{0,1,1},{1,0,1}},

{{0,1,0},{1,1,0},{0,0,1}},
{{0,1,1},{1,1,0},{1,0,1}},

{{0,0,1},{1,1,0},{0,1,0}},
{{1,0,1},{1,1,0},{0,1,1}},

{{1,0,0},{0,1,1},{0,1,0}},
{{1,0,1},{0,1,1},{1,1,0}}};//Diagonal-Branch



int bond_tables_shrink(int bond)
{
int i,j,k;
int patterns;
  if(bond==1)

{


for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_1[i][j][k];

    patterns=4;
}

}

}
}
if(bond==2)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_2[i][j][k];
    patterns=4;


}

}

}
}


if(bond==3)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_3[i][j][k];
    patterns=8;


}

}

}
}



if(bond==4)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_4[i][j][k];
    patterns=4;


}

}

}
}
 if(bond==7)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_7[i][j][k];
    patterns=4;


}

}

}
}
 if(bond==8)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_8[i][j][k];
    patterns=4;


}

}

}
}

if(bond==6)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_61[i][j][k];



}

}

}
for(i=0;i<2;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[8+i][j][k]=Shrink_6[i][j][k];
    patterns=10;


}

}

}
}
if(bond==9)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_9[i][j][k];
    patterns=8;


}

}

}
}



if(bond==5)

{


for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_51[i][j][k];
    patterns=8;


}

}

}
for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {
        Shrink[4+i][j][k]=Shrink_5[i][j][k];



}

}

}
}

if(bond==10)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
    for(k=0;k<3;k++)

    {Shrink[i][j][k]=Shrink_10[i][j][k];
    patterns=4;


}

}

}
}
return patterns;

}
void Shrinking()
{


int M[482][482];
FILE *file;
int i;
int j;
int k;
int bond=0;
int patterns;
int counter=0;
int t;
int hity;

for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{

if(Imagedata[i][j]!=0)


//calculating the bond
    bond=Imagedata[i-1][j-1]+Imagedata[i+1][j+1]+Imagedata[i+1][j-1]+Imagedata[i-1][j+1]+2*(Imagedata[i][j-1])+2*(Imagedata[i][j+1])+2*(Imagedata[i+1][j])+2*(Imagedata[i-1][j]);


   patterns= bond_tables_shrink(bond);



   counter=0;
   hity=0;

    while(counter<patterns)
    {
        if((Imagedata[i-1][j-1]==Shrink[counter][0][0])&&(Imagedata[i-1][j]==Shrink[counter][0][1])&&(Imagedata[i-1][j+1]==Shrink[counter][0][2]))
        {
              if((Imagedata[i][j-1]==Shrink[counter][1][0])&&(Imagedata[i][j]==Shrink[counter][1][1])&&(Imagedata[i][j+1]==Shrink[counter][1][2]))
              {
                  if((Imagedata[i+1][j-1]==Shrink[counter][2][0])&&(Imagedata[i+1][j]==Shrink[counter][2][1])&&(Imagedata[i+1][j+1]==Shrink[counter][2][2]))
                  {

                      counter=patterns;
                      M[i][j]=1;
                      hity=1;
                  }
              }

        }

             counter=counter+1;


    }

    if(hity!=1)
    {
        M[i][j]=0;
    }

}

}


//Runninf the conditional mask obtained through another hit or miss filter
counter=0;
int hit=0;
for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{

    counter=0;hit=0;

    if( M[i][j]!=1)
    {

        OutImagedata[i-1][j-1]=Imagedata[i][j];


    }
    if( M[i][j]==1)
    {
         while(counter<99)
    {
        if((M[i-1][j-1]== Mask[counter][0][0])&&(M[i-1][j]== Mask[counter][0][1])&&(M[i-1][j+1]== Mask[counter][0][2]))
        {
              if((M[i][j-1]== Mask[counter][1][0])&&(M[i][j]== Mask[counter][1][1])&&(M[i][j+1]== Mask[counter][1][2]))
              {
                  if((M[i+1][j-1]== Mask[counter][2][0])&&(M[i+1][j]== Mask[counter][2][1])&&(M[i+1][j+1]== Mask[counter][2][2]))
                  {

                      counter=99;
                      hit=1;
                      OutImagedata[i-1][j-1]=Imagedata[i][j];

                  }
              }

        }


             counter=counter+1;
    }
    if(hit!=1)
    {
          OutImagedata[i-1][j-1]=0;
    }


}


}
}

}


void convergence()
{
    int number=0;
   int sum=1;
   int i,j;
    while(number<15)
    {

        Shrinking();

    number++;

        for(i=0;i<Height+2;i++)
    {
        for(j=0;j<Width+2;j++)
        {


                Imagedata[i][j]=0;

            }
    }

        for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {


                Imagedata[i+1][j+1]=OutImagedata[i][j];

            }
    }


    }




         for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {
     OutImagedata_final[i][j]=OutImagedata[i][j];
     }
    }
}
//Counting the no of squares in the image
void counting()
{
    int i;
    int j;
    int size_s;
    for(i=0;i<Height;i++)
    {

        for(j=0;j<Width;j++)
        {
             size_s=0;
        if(Imagedata_notbin[i][j]!=0)
        {
            if((Imagedata_notbin[i][j-1]==0)&&(Imagedata_notbin[i-1][j]==0))
            {
                while(Imagedata_notbin[i+size_s][j]!=0)
                {
                    size_s++;
                }
                squares[size_s]++;
            }
        }

        }
    }
     cout<<"size i,number of squares of size i,"<<endl;
     int t;
    for(i=0;i<19;i++)
    {
        if(squares[i]!=0)
        {

           t=squares[i];
            cout<<i;
            cout<<",";
            cout<<t<<endl;

        }
    }

}


int main()
{

int i;int j;
FILE *file;
if (!(file=fopen("squares.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(Imagedata_notbin, sizeof(unsigned char),480*480, file);
fclose(file);
int t;

for(j=0;j<Width+2;j++)
{
Imagedata[0][j]=0;
Imagedata[Height+1][j]=0;
}
for(i=0;i<Height+2;i++)
{
Imagedata[i][0]=0;
Imagedata[i][Width+1]=0;
}

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
t=(int)Imagedata_notbin[i][j];
if (t>=250)
    {
     Imagedata[i+1][j+1]=1;
    }
    else
    {
        Imagedata[i+1][j+1]=0;
    }
}
}
convergence();


unsigned char outImage[480][480];
int total;

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
    outImage[i][j]=(unsigned char)(OutImagedata_final[i][j])*255;
    if(OutImagedata_final[i][j]==1)
    {
        total++;
    }

}
}

if (!(file=fopen("shrink_output.raw","wb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fwrite(outImage, sizeof(unsigned char),480*480, file);
fclose(file);
cout<<"total number of squares:"<<endl;
cout<<total<<endl;
counting();


return 0;
}
1)b Thinning
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>

using namespace std;

int Height=480;
int Width=480;
unsigned char Imagedata_notbin[480][480];
unsigned char previous[482][482];


int OutImagedata[480][480];
int OutImagedata_final[480][480];
int Imagedata[482][482];
int Thin[10][3][3]=

{{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}}};

//int Ske[10][3][3]=
//{{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}},
//{{0,0,0},{0,0,0},{0,0,0}}};

//int Ske_41[4][3][3]={{{0,1,0},{0,1,1},{0,0,0}},
//{{0,1,0},{1,1,0},{0,0,0}},
//{{0,0,0},{1,1,0},{0,1,0}},
//{{0,0,0},{0,1,1},{0,1,0}}};
//
//
//
//
//
//int Ske_4[4][3][3]={{{0,0,1},{0,1,1},{0,0,1}},
//{{1,1,1},{0,1,0},{0,0,0}},
//{{1,0,0},{1,1,0},{1,0,0}},
//{{0,0,0},{0,1,0},{1,1,1}}};
//
//
//
//
//
//int Ske_61[8][3][3]={{{1,1,1},{0,1,1},{0,0,0}},
//
//{{0,1,1},{0,1,1},{0,0,1}},
//
//{{1,1,1},{1,1,0},{0,0,0}},
//
//{{1,1,0},{1,1,0},{1,0,0}},
//
//{{1,0,0},{1,1,0},{1,1,0}},
//
//{{0,0,0},{1,1,0},{1,1,1}},
//
//{{0,0,0},{0,1,1},{1,1,1}},
//
//{{0,0,1},{0,1,1},{0,1,1}}};
//
//
//int Ske_7[4][3][3]={{{1,1,1},{0,1,1},{0,0,1}},
//{{1,1,1},{1,1,0},{1,0,0}},
//{{1,0,0},{1,1,0},{1,1,1}},
//{{0,0,1},{0,1,1},{1,1,1}}};
//
//
//int Ske_8[4][3][3]={{{0,1,1},{0,1,1},{0,1,1}},
//{{1,1,1},{1,1,1},{0,0,0}},
//{{1,1,0},{1,1,0},{1,1,0}},
//{{0,0,0},{1,1,1},{1,1,1}}};
//
//int Ske_9[8][3][3]=
//{{{1,1,1},{0,1,1},{0,1,1}},
//{{0,1,1},{0,1,1},{1,1,1}},
//{{1,1,1},{1,1,1},{1,0,0}},
//{{1,1,1},{1,1,1},{0,0,1}},
//{{1,1,1},{1,1,0},{1,1,0}},
//{{1,1,0},{1,1,0},{1,1,1}},
//{{1,0,0},{1,1,1},{1,1,1}},
//{{0,0,1},{1,1,1},{1,1,1}}};
//
//
//int Ske_10[4][3][3]=
//{{{1,1,1},{0,1,1},{1,1,1}},
//{{1,1,1},{1,1,1},{1,0,1}},
//{{1,1,1},{1,1,0},{1,1,1}},
//{{1,0,1},{1,1,1},{1,1,1}}};
//
//int Ske_11[4][3][3]=
//{{{1,1,1},{1,1,1},{0,1,1}},
//{{1,1,1},{1,1,1},{1,1,0}},
//{{1,1,0},{1,1,1},{1,1,1}},
//{{0,1,1},{1,1,1},{1,1,1}}};

//Thin conditional Masks start here//

int Thin_41[4][3][3]=
{{{0,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{1,1,0},{0,1,0}},
{{0,0,0},{0,1,1},{0,1,0}}};

int Thin_4[4][3][3]=
{{{0,0,1},{0,1,1},{0,0,1}},
{{1,1,1},{0,1,0},{0,0,0}},
{{1,0,0},{1,1,0},{1,0,0}},
{{0,0,0},{0,1,0},{1,1,1}}};



int Thin_5[4][3][3]=
{{{1,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{0,1,1},{0,0,1}},
{{0,1,1},{1,1,0},{0,0,0}},
{{0,0,1},{0,1,1},{0,1,0}}};


int Thin_51[4][3][3]=
{{{0,1,1},{0,1,1},{0,0,0}},
{{1,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{1,1,0},{1,1,0}},
{{0,0,0},{0,1,1},{0,1,1}}};

int Thin_61[8][3][3]=
{{{1,1,1},{0,1,1},{0,0,0}},

{{0,1,1},{0,1,1},{0,0,1}},

{{1,1,1},{1,1,0},{0,0,0}},

{{1,1,0},{1,1,0},{1,0,0}},

{{1,0,0},{1,1,0},{1,1,0}},

{{0,0,0},{1,1,0},{1,1,1}},

{{0,0,0},{0,1,1},{1,1,1}},

{{0,0,1},{0,1,1},{0,1,1}}};


int Thin_6[2][3][3]=
{{{1,1,0},{0,1,1},{0,0,1}},
{{0,1,1},{1,1,0},{1,0,0}}};

int Thin_7[4][3][3]=
{{{1,1,1},{0,1,1},{0,0,1}},
{{1,1,1},{1,1,0},{1,0,0}},
{{1,0,0},{1,1,0},{1,1,1}},
{{0,0,1},{0,1,1},{1,1,1}}};

int Thin_8[4][3][3]=
{{{0,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{0,0,0}},
{{1,1,0},{1,1,0},{1,1,0}},
{{0,0,0},{1,1,1},{1,1,1}}};

int Thin_9[8][3][3]=
{{{1,1,1},{0,1,1},{0,1,1}},
{{0,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{0,0,1},{1,1,1},{1,1,1}}};


int Thin_10[4][3][3]=
{{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,0},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}}};

int Mask[100][3][3]=
{{{0,0,1},{0,1,0},{0,0,0}},
{{1,0,0},{0,1,0},{0,0,0}},
{{0,0,0},{0,1,0},{0,1,0}},
{{0,0,0},{0,1,1},{0,0,0}},//Single-4-connection//
{{0,0,1},{0,1,1},{0,0,0}},
{{0,1,1},{0,1,0},{0,0,0}},
{{1,1,0},{0,1,0},{0,0,0}},
{{1,0,0},{1,1,0},{0,0,0}},
{{0,0,0},{1,1,0},{1,0,0}},
{{0,0,0},{0,1,0},{1,1,0}},
{{0,0,0},{0,1,0},{0,1,1}},
{{0,0,0},{0,1,1},{0,0,1}},//L-cluster
{{0,1,1},{1,1,0},{0,0,0}},
{{1,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{0,1,1},{0,0,1}},
{{0,0,1},{0,1,1},{0,1,0}},//4-connected-offeset
{{0,0,1},{0,1,1},{1,0,0}},
{{0,1,1},{0,1,0},{1,0,0}},
{{0,1,1},{0,1,1},{1,0,0}},
{{1,0,0},{1,1,0},{0,0,1}},
{{1,1,0},{0,1,0},{0,0,1}},
{{1,1,0},{1,1,0},{0,0,1}},
{{0,0,1},{0,1,0},{1,1,0}},
{{0,0,1},{1,1,0},{1,0,0}},
{{0,0,1},{1,1,0},{1,1,0}},
{{1,0,0},{0,1,0},{0,1,1}},
{{1,0,0},{0,1,1},{0,0,1}},
{{1,0,0},{0,1,1},{0,1,1}},//Spur-corner-cluster
{{1,1,0},{1,1,0},{0,0,0}},
{{1,1,1},{1,1,1},{1,1,1}},//Corner-Cluster
{{0,1,0},{1,1,1},{0,0,0}},
{{1,1,0},{1,1,1},{1,0,0}},
{{0,1,1},{1,1,1},{0,0,1}},
{{0,0,0},{1,1,1},{0,1,0}},
{{0,0,1},{1,1,1},{0,1,1}},
{{1,0,0},{1,1,1},{1,1,0}},
{{0,1,0},{1,1,0},{0,1,0}},
{{1,1,1},{1,1,0},{0,1,0}},
{{0,1,0},{1,1,0},{1,1,1}},
{{0,1,0},{0,1,1},{0,1,0}},
{{0,1,0},{0,1,1},{1,1,1}},
{{1,1,1},{0,1,1},{0,1,0}},//tee-branch
{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{0,1,0}},
{{1,0,1},{0,1,0},{0,1,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,1,0}},
{{1,0,1},{0,1,0},{1,1,1}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,1},{0,1,0}},
{{1,1,1},{1,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,1},{1,1,0}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,1},{1,0,0}},
{{1,0,0},{0,1,1},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,1},{1,0,0}},
{{1,0,1},{0,1,1},{1,0,1}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,0}},
{{1,1,0},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,1},{1,1,0},{1,1,1}},
{{0,0,1},{0,1,0},{1,0,1}},
{{0,1,0},{0,1,0},{1,0,1}},
{{0,1,1},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,1,0},{0,1,0},{1,0,1}},
{{1,1,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}},
{{0,0,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,0,1}},
{{0,0,1},{1,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{1,1,0},{0,0,1}},
{{1,0,1},{1,1,0},{1,0,1}},
{{0,1,1},{0,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{0,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,1,1}},//VEE BRANCH
{{0,1,0},{0,1,1},{1,0,0}},
{{1,1,0},{0,1,1},{1,0,1}},
{{0,1,0},{1,1,0},{0,0,1}},
{{0,1,1},{1,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,1,0}},
{{1,0,1},{1,1,0},{0,1,1}},
{{1,0,0},{0,1,1},{0,1,0}},
{{1,0,1},{0,1,1},{1,1,0}}};//Diagonal-Branch
//
int Mask2[830][3][3]=
{{{0,0,0},{0,1,0},{0,0,1}},
{{0,0,0},{0,1,0},{1,0,0}},
{{0,0,1},{0,1,0},{0,0,0}},
{{1,0,0},{0,1,0},{0,0,0}},//Spur
{{0,0,0},{0,1,0},{0,1,0}},
{{0,0,0},{0,1,1},{0,0,0}},
{{0,0,0},{1,1,0},{0,0,0}},
{{0,1,0},{0,1,0},{0,0,0}},//Single_connection
{{0,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{0,1,1},{0,1,0}},
{{0,0,0},{1,1,0},{0,1,0}},//L corner
{{0,1,0},{1,1,1},{0,0,0}},
{{1,1,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,0},{0,1,0}},
{{0,0,0},{1,1,1},{0,1,0}},
{{0,1,0},{0,1,1},{0,1,0}},//Tee branch-17
{{1,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{0,1,1},{0,1,1}},
{{0,1,0},{0,1,1},{1,0,0}},
{{1,1,0},{0,1,1},{1,0,1}},
{{0,1,0},{1,1,0},{0,0,1}},
{{0,1,1},{1,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,1,0}},
{{1,0,1},{1,1,0},{0,1,1}},
{{1,0,0},{0,1,1},{0,1,0}},
{{1,0,1},{0,1,1},{1,1,0}},//Diagonal Branch-27
{{1,0,1},{1,1,1},{0,0,1}},
{{1,0,1},{1,1,1},{0,1,0}},
{{1,0,1},{1,1,1},{0,1,1}},
{{1,0,1},{1,1,1},{1,0,0}},
{{1,0,1},{1,1,1},{1,0,1}},
{{1,0,1},{1,1,1},{1,1,0}},
{{1,0,1},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,1},{0,1,0}},
{{1,1,1},{1,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,1},{1,1,0}},
{{1,1,1},{1,1,1},{1,1,1}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,1},{1,0,0}},
{{1,0,0},{0,1,1},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,1},{1,0,0}},
{{1,0,1},{0,1,1},{1,0,1}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,0}},
{{1,1,0},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,1},{1,1,0},{1,1,1}},
{{1,1,1},{1,1,1},{1,1,0}},

{{0,0,1},{0,1,0},{1,0,1}},
{{0,1,0},{0,1,0},{1,0,1}},
{{0,1,1},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,1,0},{0,1,0},{1,0,1}},
{{1,1,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,1}},

{{0,0,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,0,1}},
{{0,0,1},{1,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{1,1,0},{0,0,1}},
{{1,0,1},{1,1,0},{1,0,1}},

{{0,1,1},{0,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{0,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,1,1}}};

int bond_tables_thin(int bond)
{
int i,j,k;
int patterns=0;

if(bond==4)

{

for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Thin[i][j][k]=Thin_4[i][j][k];
patterns=8;


}

}

}

for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Thin[i+4][j][k]=Thin_41[i][j][k];


}

}

}

}

if(bond==5)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Thin[i][j][k]=Thin_5[i][j][k];
patterns=8;


}

}

}

for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Thin[i+4][j][k]=Thin_51[i][j][k];


}

}

}

}

if(bond==7)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[i][j][k]=Thin_7[i][j][k];
patterns=4;


}

}

}
}
if(bond==8)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[i][j][k]=Thin_8[i][j][k];
patterns=4;


}

}

}
}

if(bond==6)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[i][j][k]=Thin_61[i][j][k];



}

}

}
for(i=0;i<2;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[8+i][j][k]=Thin_6[i][j][k];
patterns=10;


}

}

}
}
if(bond==9)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[i][j][k]=Thin_9[i][j][k];
patterns=8;


}

}

}
}


if(bond==10)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Thin[i][j][k]=Thin_10[i][j][k];
patterns=4;


}

}

}
}
return patterns;

}

void thinning()
{
int M[482][482];
FILE *file;
int i;
int j;
int k;
int bond=0;
int patterns;
int counter=0;
int t;
int hity;

for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{

if(Imagedata[i][j]!=0)


//calculating the bond
    bond=Imagedata[i-1][j-1]+Imagedata[i+1][j+1]+Imagedata[i+1][j-1]+Imagedata[i-1][j+1]+2*(Imagedata[i][j-1])+2*(Imagedata[i][j+1])+2*(Imagedata[i+1][j])+2*(Imagedata[i-1][j]);


   patterns= bond_tables_thin(bond);



   counter=0;
   hity=0;

    while(counter<patterns)
    {
        if((Imagedata[i-1][j-1]==Thin[counter][0][0])&&(Imagedata[i-1][j]==Thin[counter][0][1])&&(Imagedata[i-1][j+1]==Thin[counter][0][2]))
        {
              if((Imagedata[i][j-1]==Thin[counter][1][0])&&(Imagedata[i][j]==Thin[counter][1][1])&&(Imagedata[i][j+1]==Thin[counter][1][2]))
              {
                  if((Imagedata[i+1][j-1]==Thin[counter][2][0])&&(Imagedata[i+1][j]==Thin[counter][2][1])&&(Imagedata[i+1][j+1]==Thin[counter][2][2]))
                  {

                      counter=patterns;
                      M[i][j]=1;
                      hity=1;
                  }
              }

        }

             counter=counter+1;


    }

    if(hity!=1)
    {
        M[i][j]=0;
    }

}

}


//Runninf the conditional mask obtained through another hit or miss filter
counter=0;
int hit=0;
for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{



    if( M[i][j]!=1)
    {

        OutImagedata[i-1][j-1]=Imagedata[i][j];


    }
    if( M[i][j]==1)
    {
           counter=0;hit=0;
         while(counter<100)
    {
        if((M[i-1][j-1]== Mask[counter][0][0])&&(M[i-1][j]== Mask[counter][0][1])&&(M[i-1][j+1]== Mask[counter][0][2]))
        {
              if((M[i][j-1]== Mask[counter][1][0])&&(M[i][j]== Mask[counter][1][1])&&(M[i][j+1]== Mask[counter][1][2]))
              {
                  if((M[i+1][j-1]== Mask[counter][2][0])&&(M[i+1][j]== Mask[counter][2][1])&&(M[i+1][j+1]== Mask[counter][2][2]))
                  {

                      counter=100;
                      hit=1;
                      OutImagedata[i-1][j-1]=Imagedata[i][j];

                  }
              }

        }


             counter=counter+1;
    }
    if(hit!=1)
    {
          OutImagedata[i-1][j-1]=0;
    }


}


}
}

}
void convergence()
{
    int number=0;
   int sum=1;
   int i,j;
    while(number<70)
    {

        thinning();

    number++;

        for(i=0;i<Height+2;i++)
    {
        for(j=0;j<Width+2;j++)
        {


                Imagedata[i][j]=0;

            }
    }

        for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {


                Imagedata[i+1][j+1]=OutImagedata[i][j];

            }
    }


    }




         for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {
     OutImagedata_final[i][j]=OutImagedata[i][j];
     }
    }
}





int main()
{

int i;int j;

FILE *file;
if (!(file=fopen("letterE.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(Imagedata_notbin, sizeof(unsigned char),480*480, file);
fclose(file);
int t;

for(j=0;j<Width+2;j++)
{
Imagedata[0][j]=0;
Imagedata[Height+1][j]=0;
}
for(i=0;i<Height+2;i++)
{
Imagedata[i][0]=0;
Imagedata[i][Width+1]=0;
}

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
t=(int)Imagedata_notbin[i][j];
if (t==255)
{
Imagedata[i+1][j+1]=1;
}
else
{
Imagedata[i+1][j+1]=0;
}
}
}
convergence();
//Thinning();

unsigned char outImage[480][480];

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
outImage[i][j]=(unsigned char)(OutImagedata_final[i][j])*255;


}
}

if (!(file=fopen("Thinning.raw","wb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fwrite(outImage, sizeof(unsigned char),480*480, file);
fclose(file);



return 0;
}
----------------------------------------------------
3)Skeletonizng
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include<math.h>

using namespace std;

int Height=480;
int Width=480;
unsigned char Imagedata_notbin[480][480];
unsigned char previous[482][482];


int OutImagedata[480][480];
int OutImagedata_final[480][480];
int Imagedata[482][482];
int Ske[10][3][3]=
{{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}},
{{0,0,0},{0,0,0},{0,0,0}}};



int Ske_41[4][3][3]={{{0,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{1,1,0},{0,1,0}},
{{0,0,0},{0,1,1},{0,1,0}}};





int Ske_4[4][3][3]={{{0,0,1},{0,1,1},{0,0,1}},
{{1,1,1},{0,1,0},{0,0,0}},
{{1,0,0},{1,1,0},{1,0,0}},
{{0,0,0},{0,1,0},{1,1,1}}};





int Ske_61[8][3][3]={{{1,1,1},{0,1,1},{0,0,0}},

{{0,1,1},{0,1,1},{0,0,1}},

{{1,1,1},{1,1,0},{0,0,0}},

{{1,1,0},{1,1,0},{1,0,0}},

{{1,0,0},{1,1,0},{1,1,0}},

{{0,0,0},{1,1,0},{1,1,1}},

{{0,0,0},{0,1,1},{1,1,1}},

{{0,0,1},{0,1,1},{0,1,1}}};


int Ske_7[4][3][3]={{{1,1,1},{0,1,1},{0,0,1}},
{{1,1,1},{1,1,0},{1,0,0}},
{{1,0,0},{1,1,0},{1,1,1}},
{{0,0,1},{0,1,1},{1,1,1}}};


int Ske_8[4][3][3]={{{0,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{0,0,0}},
{{1,1,0},{1,1,0},{1,1,0}},
{{0,0,0},{1,1,1},{1,1,1}}};

int Ske_9[8][3][3]=
{{{1,1,1},{0,1,1},{0,1,1}},
{{0,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{0,0,1},{1,1,1},{1,1,1}}};


int Ske_10[4][3][3]=
{{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,0},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}}};

int Ske_11[4][3][3]=
{{{1,1,1},{1,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{1,1,0}},
{{1,1,0},{1,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{1,1,1}}};

//Thin conditional Masks start here//
//
//int Thin_4[4][3][3]={{{0,0,1},{0,1,1},{0,0,1}},
//{{1,1,1},{0,1,0},{0,0,0}},
//{{1,0,0},{1,1,0},{1,0,0}},
//{{0,0,0},{0,1,0},{1,1,1}}};
//
//int Thin_41[4][3][3]={{{0,1,0},{0,1,1},{0,0,0}},
//{{0,1,0},{1,1,0},{0,0,0}},
//{{0,0,0},{1,1,0},{0,1,0}},
//{{0,0,0},{0,1,1},{0,1,0}}};
//
//int Thin_5[4][3][3]={{{1,1,0},{0,1,1},{0,0,0}},
//{{0,1,0},{0,1,1},{0,0,1}},
//{{0,1,1},{1,1,0},{0,0,0}},
//{{0,0,1},{0,1,1},{0,1,0}}};
//
//
//int Thin_51[4][3][3]={{{0,1,1},{0,1,1},{0,0,0}},
//{{1,1,0},{1,1,0},{0,0,0}},
//{{0,0,0},{1,1,0},{1,1,0}},
//{{0,0,0},{0,1,1},{0,1,1}}};
//
//int Thin_61[8][3][3]={{{1,1,1},{0,1,1},{0,0,0}},
//
//{{0,1,1},{0,1,1},{0,0,1}},
//
//{{1,1,1},{1,1,0},{0,0,0}},
//
//{{1,1,0},{1,1,0},{1,0,0}},
//
//{{1,0,0},{1,1,0},{1,1,0}},
//
//{{0,0,0},{1,1,0},{1,1,1}},
//
//{{0,0,0},{0,1,1},{1,1,1}},
//
//{{0,0,1},{0,1,1},{0,1,1}}};
//
//
//int Thin_6[2][3][3]={{{1,1,0},{0,1,1},{0,0,1}},
//{{0,1,1},{1,1,0},{1,0,0}}};
//
//int Thin_7[4][3][3]={{{1,1,1},{0,1,1},{0,0,1}},
//{{1,1,1},{1,1,0},{1,0,0}},
//{{1,0,0},{1,1,0},{1,1,1}},
//{{0,0,1},{0,1,1},{1,1,1}}};
//
//int Thin_8[4][3][3]={{{0,1,1},{0,1,1},{0,1,1}},
//{{1,1,1},{1,1,1},{0,0,0}},
//{{1,1,0},{1,1,0},{1,1,0}},
//{{0,0,0},{1,1,1},{1,1,1}}};
//
//int Thin_9[8][3][3]=
//{{{1,1,1},{0,1,1},{0,1,1}},
//{{0,1,1},{0,1,1},{1,1,1}},
//{{1,1,1},{1,1,1},{1,0,0}},
//{{1,1,1},{1,1,1},{0,0,1}},
//{{1,1,1},{1,1,0},{1,1,0}},
//{{1,1,0},{1,1,0},{1,1,1}},
//{{1,0,0},{1,1,1},{1,1,1}},
//{{0,0,1},{1,1,1},{1,1,1}}};
//
//
//int Thin_10[4][3][3]=
//{{{1,1,1},{0,1,1},{1,1,1}},
//{{1,1,1},{1,1,1},{1,0,1}},
//{{1,1,1},{1,1,0},{1,1,1}},
//{{1,0,1},{1,1,1},{1,1,1}}};

//int Mask[100][3][3]=
//{{{0,0,1},{0,1,0},{0,0,0}},
//{{1,0,0},{0,1,0},{0,0,0}},
//
//{{0,0,0},{0,1,0},{0,1,0}},
//
//{{0,0,0},{0,1,1},{0,0,0}},//Single-4-connection//
//
//{{0,0,1},{0,1,1},{0,0,0}},
//{{0,1,1},{0,1,0},{0,0,0}},
//{{1,1,0},{0,1,0},{0,0,0}},
//{{1,0,0},{1,1,0},{0,0,0}},
//{{0,0,0},{1,1,0},{1,0,0}},
//{{0,0,0},{0,1,0},{1,1,0}},
//{{0,0,0},{0,1,0},{0,1,1}},
//{{0,0,0},{0,1,1},{0,0,1}},//L-cluster
//
//{{0,1,1},{1,1,0},{0,0,0}},
//{{1,1,0},{0,1,1},{0,0,0}},
//{{0,1,0},{0,1,1},{0,0,1}},
//{{0,0,1},{0,1,1},{0,1,0}},//4-connected-offeset
//
//{{0,0,1},{0,1,1},{1,0,0}},
//{{0,1,1},{0,1,0},{1,0,0}},
//{{0,1,1},{0,1,1},{1,0,0}},
//
//{{1,0,0},{1,1,0},{0,0,1}},
//{{1,1,0},{0,1,0},{0,0,1}},
//{{1,1,0},{1,1,0},{0,0,1}},
//
//{{0,0,1},{0,1,0},{1,1,0}},
//{{0,0,1},{1,1,0},{1,0,0}},
//{{0,0,1},{1,1,0},{1,1,0}},
//
//{{1,0,0},{0,1,0},{0,1,1}},
//{{1,0,0},{0,1,1},{0,0,1}},
//{{1,0,0},{0,1,1},{0,1,1}},//Spur-corner-cluster
//
//{{1,1,0},{1,1,0},{0,0,0}},
//{{1,1,1},{1,1,1},{1,1,1}},//Corner-Cluster
//
//{{0,1,0},{1,1,1},{0,0,0}},
//{{1,1,0},{1,1,1},{1,0,0}},
//
//{{0,1,1},{1,1,1},{0,0,1}},
//
//{{0,0,0},{1,1,1},{0,1,0}},
//{{0,0,1},{1,1,1},{0,1,1}},
//
//{{1,0,0},{1,1,1},{1,1,0}},
//
//{{0,1,0},{1,1,0},{0,1,0}},
//{{1,1,1},{1,1,0},{0,1,0}},
//
//{{0,1,0},{1,1,0},{1,1,1}},
//
//{{0,1,0},{0,1,1},{0,1,0}},
//{{0,1,0},{0,1,1},{1,1,1}},
//
//{{1,1,1},{0,1,1},{0,1,0}},//tee-branch
//
//{{1,0,1},{0,1,0},{0,0,1}},
//{{1,0,1},{0,1,0},{0,1,0}},
//{{1,0,1},{0,1,0},{0,1,1}},
//{{1,0,1},{0,1,0},{1,0,0}},
//{{1,0,1},{0,1,0},{1,0,1}},
//{{1,0,1},{0,1,0},{1,1,0}},
//{{1,0,1},{0,1,0},{1,1,1}},
//{{1,1,1},{1,1,1},{0,0,1}},
//{{1,1,1},{1,1,1},{0,1,0}},
//{{1,1,1},{1,1,1},{0,1,1}},
//{{1,1,1},{1,1,1},{1,0,0}},
//{{1,1,1},{1,1,1},{1,0,1}},
//{{1,1,1},{1,1,1},{1,1,0}},
//
//{{1,0,0},{0,1,0},{1,0,1}},
//{{1,0,0},{0,1,1},{1,0,0}},
//{{1,0,0},{0,1,1},{1,0,1}},
//{{1,0,1},{0,1,0},{1,0,0}},
//{{1,0,1},{0,1,0},{1,0,1}},
//{{1,0,1},{0,1,1},{1,0,0}},
//{{1,0,1},{0,1,1},{1,0,1}},
//
//{{1,1,0},{1,1,0},{1,1,1}},
//{{1,1,0},{1,1,1},{1,1,0}},
//{{1,1,0},{1,1,1},{1,1,1}},
//{{1,1,1},{1,1,0},{1,1,0}},
//{{1,1,1},{1,1,0},{1,1,1}},
//
//{{0,0,1},{0,1,0},{1,0,1}},
//{{0,1,0},{0,1,0},{1,0,1}},
//{{0,1,1},{0,1,0},{1,0,1}},
//{{1,0,0},{0,1,0},{1,0,1}},
//{{1,0,1},{0,1,0},{1,0,1}},
//{{1,1,0},{0,1,0},{1,0,1}},
//{{1,1,1},{0,1,0},{1,0,1}},
//{{0,0,1},{1,1,1},{1,1,1}},
//{{0,1,0},{1,1,1},{1,1,1}},
//{{0,1,1},{1,1,1},{1,1,1}},
//{{1,0,0},{1,1,1},{1,1,1}},
//{{1,0,1},{1,1,1},{1,1,1}},
//
//{{0,0,1},{0,1,0},{1,0,1}},
//
//{{0,0,1},{1,1,0},{0,0,1}},
//{{0,0,1},{1,1,0},{1,0,1}},
//{{1,0,1},{0,1,0},{0,0,1}},
//{{1,0,1},{0,1,0},{1,0,1}},
//{{1,0,1},{1,1,0},{0,0,1}},
//{{1,0,1},{1,1,0},{1,0,1}},
//{{0,1,1},{0,1,1},{1,1,1}},
//{{0,1,1},{1,1,1},{0,1,1}},
//{{0,1,1},{1,1,1},{1,1,1}},
//{{1,1,1},{0,1,1},{0,1,1}},
//{{1,1,1},{0,1,1},{1,1,1}},
//{{1,1,1},{1,1,1},{0,1,1}},//VEE BRANCH
//
//{{0,1,0},{0,1,1},{1,0,0}},
//{{1,1,0},{0,1,1},{1,0,1}},
//
//{{0,1,0},{1,1,0},{0,0,1}},
//{{0,1,1},{1,1,0},{1,0,1}},
//
//{{0,0,1},{1,1,0},{0,1,0}},
//{{1,0,1},{1,1,0},{0,1,1}},
//
//{{1,0,0},{0,1,1},{0,1,0}},
//{{1,0,1},{0,1,1},{1,1,0}}};//Diagonal-Branch
//
int Mask2[830][3][3]=
{{{0,0,0},{0,1,0},{0,0,1}},
{{0,0,0},{0,1,0},{1,0,0}},
{{0,0,1},{0,1,0},{0,0,0}},
{{1,0,0},{0,1,0},{0,0,0}},//Spur
{{0,0,0},{0,1,0},{0,1,0}},
{{0,0,0},{0,1,1},{0,0,0}},
{{0,0,0},{1,1,0},{0,0,0}},
{{0,1,0},{0,1,0},{0,0,0}},//Single_connection
{{0,1,0},{0,1,1},{0,0,0}},
{{0,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{0,1,1},{0,1,0}},
{{0,0,0},{1,1,0},{0,1,0}},//L corner
{{0,1,0},{1,1,1},{0,0,0}},
{{1,1,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,0},{0,1,0}},
{{0,0,0},{1,1,1},{0,1,0}},
{{0,1,0},{0,1,1},{0,1,0}},//Tee branch-17
{{1,1,0},{1,1,0},{0,0,0}},
{{0,0,0},{0,1,1},{0,1,1}},

{{0,1,0},{0,1,1},{1,0,0}},
{{1,1,0},{0,1,1},{1,0,1}},
{{0,1,0},{1,1,0},{0,0,1}},
{{0,1,1},{1,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,1,0}},
{{1,0,1},{1,1,0},{0,1,1}},
{{1,0,0},{0,1,1},{0,1,0}},
{{1,0,1},{0,1,1},{1,1,0}},//Diagonal Branch-27

{{1,0,1},{1,1,1},{0,0,1}},
{{1,0,1},{1,1,1},{0,1,0}},
{{1,0,1},{1,1,1},{0,1,1}},
{{1,0,1},{1,1,1},{1,0,0}},
{{1,0,1},{1,1,1},{1,0,1}},
{{1,0,1},{1,1,1},{1,1,0}},
{{1,0,1},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,0,1}},
{{1,1,1},{1,1,1},{0,1,0}},
{{1,1,1},{1,1,1},{0,1,1}},
{{1,1,1},{1,1,1},{1,0,0}},
{{1,1,1},{1,1,1},{1,0,1}},
{{1,1,1},{1,1,1},{1,1,0}},
{{1,1,1},{1,1,1},{1,1,1}},

{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,1},{1,0,0}},
{{1,0,0},{0,1,1},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,0}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,1},{1,0,0}},
{{1,0,1},{0,1,1},{1,0,1}},
{{1,1,0},{1,1,0},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,0}},
{{1,1,0},{1,1,1},{1,1,1}},
{{1,1,1},{1,1,0},{1,1,0}},
{{1,1,1},{1,1,0},{1,1,1}},
{{1,1,1},{1,1,1},{1,1,0}},

{{0,0,1},{0,1,0},{1,0,1}},
{{0,1,0},{0,1,0},{1,0,1}},
{{0,1,1},{0,1,0},{1,0,1}},
{{1,0,0},{0,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,1,0},{0,1,0},{1,0,1}},
{{1,1,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,1},{1,1,1}},
{{0,1,0},{1,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,0,0},{1,1,1},{1,1,1}},
{{1,0,1},{1,1,1},{1,1,1}},
{{1,1,0},{1,1,1},{1,1,1}},

{{0,0,1},{0,1,0},{1,0,1}},
{{0,0,1},{1,1,0},{0,0,1}},
{{0,0,1},{1,1,0},{1,0,1}},
{{1,0,1},{0,1,0},{0,0,1}},
{{1,0,1},{0,1,0},{1,0,1}},
{{1,0,1},{1,1,0},{0,0,1}},
{{1,0,1},{1,1,0},{1,0,1}},

{{0,1,1},{0,1,1},{1,1,1}},
{{0,1,1},{1,1,1},{0,1,1}},
{{0,1,1},{1,1,1},{1,1,1}},
{{1,1,1},{0,1,1},{0,1,1}},
{{1,1,1},{0,1,1},{1,1,1}},
{{1,1,1},{1,1,1},{0,1,1}}};


int bond_tables_ske(int bond)
{
int i,j,k;
int patterns=0;

if(bond==4)

{

for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Ske[i][j][k]=Ske_4[i][j][k];
patterns=8;


}

}

}

for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
Ske[i+4][j][k]=Ske_41[i][j][k];


}

}

}

}



if(bond==7)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Ske[i][j][k]=Ske_7[i][j][k];
patterns=4;


}

}

}
}
if(bond==8)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Ske[i][j][k]=Ske_8[i][j][k];
patterns=4;


}

}

}
}

if(bond==6)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Ske[i][j][k]=Ske_61[i][j][k];
patterns=8;


}

}

}
}
if(bond==9)

{


for(i=0;i<8;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Ske[i][j][k]=Ske_9[i][j][k];
patterns=8;


}

}

}
}


if(bond==10)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{
    Ske[i][j][k]=Ske_10[i][j][k];
patterns=4;


}

}

}
}
if(bond==11)

{



for(i=0;i<4;i++)
{
for(j=0;j<3;j++)
{
for(k=0;k<3;k++)

{Ske[i][j][k]=Ske_11[i][j][k];
patterns=4;


}

}

}
}
return patterns;

}

void Skeleton()
{


int M[482][482];
int i;
int j;
int bond=0;
int patterns=0;
int counter=0;
int hity;
//Conditional Mark Patterns
for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{

if(Imagedata[i][j]!=0)



bond=Imagedata[i-1][j-1]+Imagedata[i+1][j+1]+Imagedata[i+1][j-1]+Imagedata[i-1][j+1]+2*(Imagedata[i][j-1])+2*(Imagedata[i][j+1])+2*(Imagedata[i+1][j])+2*(Imagedata[i-1][j]);


patterns= bond_tables_ske(bond);


counter=0;
hity=0;

while(counter<patterns)
{
if((Imagedata[i-1][j-1]==Ske[counter][0][0])&&(Imagedata[i-1][j]==Ske[counter][0][1])&&(Imagedata[i-1][j+1]==Ske[counter][0][2]))
{
if((Imagedata[i][j-1]==Ske[counter][1][0])&&(Imagedata[i][j]==Ske[counter][1][1])&&(Imagedata[i][j+1]==Ske[counter][1][2]))
{
  if((Imagedata[i+1][j-1]==Ske[counter][2][0])&&(Imagedata[i+1][j]==Ske[counter][2][1])&&(Imagedata[i+1][j+1]==Ske[counter][2][2]))
  {

      counter=patterns;
      M[i][j]=1;
      hity=1;
  }
}

}

counter=counter+1;


}

if(hity!=1)
{
M[i][j]=0;
}

}

}
//UNConditional Mark Patterns
counter=0;
int hit=0;
for(i=1;i<Height+1;i++)
{
for(j=1;j<Width+1;j++)
{



if( M[i][j]!=1)
{

OutImagedata[i-1][j-1]=Imagedata[i][j];


}
if( M[i][j]==1)
{
while(counter<100)
{
if((M[i-1][j-1]== Mask2[counter][0][0])&&(M[i-1][j]== Mask2[counter][0][1])&&(M[i-1][j+1]== Mask2[counter][0][2]))
{
if((M[i][j-1]== Mask2[counter][1][0])&&(M[i][j]== Mask2[counter][1][1])&&(M[i][j+1]== Mask2[counter][1][2]))
{
  if((M[i+1][j-1]== Mask2[counter][2][0])&&(M[i+1][j]== Mask2[counter][2][1])&&(M[i+1][j+1]== Mask2[counter][2][2]))
  {

      counter=100;
      hit=1;
      OutImagedata[i-1][j-1]=Imagedata[i][j];

  }
}

}


counter=counter+1;
}
if(hit!=1)
{
OutImagedata[i-1][j-1]=0;
}


}


}
}

}

void convergence()
{
    int number=0;
   int sum=1;
   int i,j;
    while(number<100)
    {

        Skeleton();

    number++;

        for(i=0;i<Height+2;i++)
    {
        for(j=0;j<Width+2;j++)
        {


                Imagedata[i][j]=0;

            }
    }

        for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {


                Imagedata[i+1][j+1]=OutImagedata[i][j];

            }
    }


    }




         for(i=0;i<Height;i++)
    {
        for(j=0;j<Width;j++)
        {
     OutImagedata_final[i][j]=OutImagedata[i][j];
     }
    }
}





int main()
{

int i;int j;

FILE *file;
if (!(file=fopen("LetterE.raw","rb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fread(Imagedata_notbin, sizeof(unsigned char),480*480, file);
fclose(file);
int t;

for(j=0;j<Width+2;j++)
{
Imagedata[0][j]=0;
Imagedata[Height+1][j]=0;
}
for(i=0;i<Height+2;i++)
{
Imagedata[i][0]=0;
Imagedata[i][Width+1]=0;
}

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
t=(int)Imagedata_notbin[i][j];
if (t==255)
{
Imagedata[i+1][j+1]=1;
}
else
{
Imagedata[i+1][j+1]=0;
}
}
}
convergence();


unsigned char outImage[480][480];

for(i=0;i<Height;i++)
{
for(j=0;j<Width;j++)
{
outImage[i][j]=(unsigned char)(OutImagedata_final[i][j])*255;


}
}

if (!(file=fopen("Skeleton.raw","wb")))
{
cout << "Cannot open file: " <<endl;
exit(1);
}
fwrite(outImage, sizeof(unsigned char),480*480, file);
fclose(file);



return 0;
}


